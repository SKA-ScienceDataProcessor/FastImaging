#ifndef IMAGER_H
#define IMAGER_H

// STP library includes
#include "../common/fft.h"
#include "../gridder/gridder.h"

#include <experimental/optional>

#define arc_sec_to_rad(value) ((value / 3600.0) * (M_PI / 180.0))

namespace stp {

const double image_slice = 0;
const double beam_slice = 1;

/**
 * @brief image_visibilities function
 *
 * This function (template + functor) create a two arrays representing the image map and beam model.
 *
 * @param[in] vis (cx_mat): Complex visibilities
 * @param[in] uvw_lambda (cx_mat): UVW-coordinates of visibilities. Units are multiples of wavelength.
 * @param[in] image_size (int): Width of the image in pixels
 * @param[in] cell_size (double): Angular-width of a synthesized pixel in the image to be created
 * @param[in] support (double): Defines the 'radius' of the bounding box within which convolution takes place.
 * @param[in] oversampling (Oversampling): Controls kernel-generation
 * @param[in] normalize (bool): Whether or not the returned image and beam should be normalized such that the beam peaks at a value of 1.0 Jansky.
 *                              You normally want this to be true, but it may be interesting to check the raw values for debugging purposes.
 *
 * @return (std::pair<arma::cx_mat, arma::cx_mat>) 2 slices: result of the FFT on the image and beam slices generated by gridding and convolution
 */
template <typename T>
std::pair<arma::cx_mat, arma::cx_mat> image_visibilities(
    const T& kernel_creator,
    arma::cx_mat vis,
    arma::mat uvw_lambda,
    int image_size,
    double cell_size,
    double support,
    const std::experimental::optional<int>& oversampling,
    bool normalize = true)
{
    // Size of a UV-grid pixel, in multiples of wavelength (lambda):
    double grid_pixel_width_lambda = (1.0 / (arc_sec_to_rad(cell_size) * image_size));
    arma::mat uvw_in_pixels = uvw_lambda / grid_pixel_width_lambda;

    arma::mat uv_in_pixels(uvw_in_pixels.n_rows, 2);
    uv_in_pixels.col(0) = uvw_in_pixels.col(0);
    uv_in_pixels.col(1) = uvw_in_pixels.col(1);

    return process_image_visibilities(kernel_creator, support, image_size, uv_in_pixels, vis, oversampling, normalize);
}

template <typename T>
std::pair<arma::cx_mat, arma::cx_mat> process_image_visibilities(
    const T& kernel_creator,
    int support,
    int image_size,
    arma::mat& uv_in_pixels,
    arma::cx_mat& vis,
    const std::experimental::optional<int>& oversampling,
    bool normalize = true)
{
    std::pair<arma::cx_mat, arma::cx_mat> result = convolve_to_grid(kernel_creator, support, image_size, uv_in_pixels, vis, oversampling);

    arma::cx_mat shifted_image = fftshift(result.first, false);
    arma::cx_mat shifted_beam = fftshift(result.second, false);

#ifdef _ARMAFFT
    // Armadillo implementation
    arma::cx_mat fft_result_image = fftshift(fft_arma(shifted_image, true));
    arma::cx_mat fft_result_beam = fftshift(fft_arma(shifted_beam, true));
#else
    // FFTW implementation
    arma::cx_mat fft_result_image = fftshift(fft_fftw(shifted_image, true));
    arma::cx_mat fft_result_beam = fftshift(fft_fftw(shifted_beam, true));
#endif

    // Normalize image and beam such that the beam peaks at a value of 1.0 Jansky.
    if (normalize == true) {
        double beam_max = arma::real(fft_result_beam).max();
        fft_result_beam /= beam_max;
        fft_result_image /= beam_max;
    }

    return std::make_pair(std::move(fft_result_image), std::move(fft_result_beam));
}
}
#endif /* IMAGER_H */
