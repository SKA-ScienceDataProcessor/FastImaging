<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Slow Transients Pipeline Prototype: Slow Transients Pipeline Prototype</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="science_data_processor_logo.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Slow Transients Pipeline Prototype
   </div>
   <div id="projectbrief">Component of the Science Data Processor being developed in the context of the Square Kilometre Array international project, which provides fast snapshot imaging, object detection and cataloguing for the identification of astrophysical image-plane transients.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Slow Transients Pipeline Prototype </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Project organisation</h2>
<ul>
<li>doc: documentation files<ul>
<li>html: auto-generated doxygen documentation</li>
</ul>
</li>
<li>src: source code files (.cpp and .h)<ul>
<li>stp: the STP library code</li>
<li>stp-python: python bindings for STP library</li>
<li>reduce: command-line tools for the execution of the STP on arbitrary numpy data</li>
<li>test: unit tests for the STP library</li>
<li>benchmark: functions for benchmarking of STP library</li>
<li>auxiliary: external functions to auxiliate tests, benchmark and reduce module</li>
<li>third-party: external code, mostly libraries</li>
</ul>
</li>
<li>configs: auxiliary configuration files</li>
<li>test-data: input test data files</li>
<li>scripts: auxiliary scripts to generate FFTW wisdom files and test python bindings</li>
<li>vagrant: virtual machine configuration</li>
</ul>
<h2>Build &amp; Run</h2>
<h3>Dependencies</h3>
<h4>In Source (third-party)</h4>
<ul>
<li><a href="http://arma.sourceforge.net/">Armadillo</a> [7.950.1]</li>
<li><a href="https://github.com/google/googletest">Google Test</a> [1.8.0]</li>
<li><a href="https://github.com/google/benchmark">Google Benchmark</a> [1.1.0]</li>
<li><a href="https://github.com/rogersce/cnpy">cnpy</a> [repository head]</li>
<li><a href="http://www.fftw.org/">FFTW3</a> [3.3.5]</li>
<li><a href="https://github.com/pybind/pybind11">pybind11</a> [2.0.0]</li>
<li><a href="https://www.threadingbuildingblocks.org/">TBB</a> [2017 Update 3]</li>
<li><a href="http://www.openblas.net">OpenBLAS</a> [0.2.19]</li>
<li><a href="https://github.com/miloyip/rapidjson">RapidJSON</a> [1.1.0]</li>
<li><a href="http://tclap.sourceforge.net/">TCLAP</a> [1.2.1]</li>
<li><a href="https://github.com/gabime/spdlog">spdlog</a> [0.14.0]</li>
<li><a href="http://eigen.tuxfamily.org/">Eigen</a> [3.3.4]</li>
<li><a href="http://ceres-solver.org/">Ceres Solver</a> [1.13.0rc1]</li>
</ul>
<h3>Clone</h3>
<div class="fragment"><div class="line">$ git clone https://github.com/SKA-ScienceDataProcessor/FastImaging.git</div><div class="line">$ cd &lt;path/to/project&gt;</div><div class="line">$ git submodule init</div><div class="line">$ git submodule update    # Update test-data directory</div></div><!-- fragment --><h3>Build</h3>
<p>To build the STP prototype, the following CMake options are available:</p>
<table class="doxtable">
<tr>
<th>OPTION </th><th>Description  </th></tr>
<tr>
<td>BUILD_TESTS </td><td>Builds the unit tests (default=ON) </td></tr>
<tr>
<td>BUILD_BENCHMARK </td><td>Builds the benchmark tests (default=ON) </td></tr>
<tr>
<td>USE_GLIBCXX_PARALLEL </td><td>Uses GLIBCXX parallel mode - required for parallel nth_element (default=ON) </td></tr>
<tr>
<td>USE_FLOAT </td><td>Builds STP using FLOAT type to represent large arrays of real/complex numbers (default=ON) </td></tr>
<tr>
<td>WITH_FUNCTION_TIMINGS </td><td>Measures function execution times from the reduce executable (default=ON) </td></tr>
<tr>
<td>USE_SERIAL_GRIDDER </td><td>Uses serial implementation of gridder (default=OFF) </td></tr>
<tr>
<td>USE_FFTSHIFT </td><td>Explicitly performs FFT shifting of the image matrix (and beam if generated) after the FFT - results in slower imager (default=OFF) </td></tr>
</table>
<p>When compiled with USE_FLOAT=ON, the large data arrays of real or complex numbers use the single-precision floating-point representation instead of the double-precision floating-point. In most systems the FLOAT type uses 4 bytes while DOUBLE uses 8 bytes. Thus, using FLOAT allows to reduce the memory usage and consequently the pipeline running time. However, it reduces the algorithm's accuracy.</p>
<p>After building STP, the FFTW wisdom files shall be generated using the fftw-wisdom tool. By using these files, the FFT step executes much faster. A CMake target is provided to generate the FFTW wisdom files. This target executes a script located in "project-root/scripts/fftw-wisdom" directory. The location and filename of the generated FFTW wisdom files shall be provided in the input JSON configuration file.</p>
<p>By default, FFTW wisdom files are generated for the following matrix sizes: 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536. When executing the STP only the above image sizes can be used as input, since the FFTW wisdom files were generated only for these sizes. If different image sizes are required, the script for wisdom file generation shall be manually executed indicating the required image sizes.</p>
<p>#### Using a build script (Includes tests execution) </p><div class="fragment"><div class="line">$ cd &lt;path/to/project&gt;</div><div class="line">$ chmod +x build.sh</div><div class="line">$ ./build.sh &lt;OPTIONS&gt;</div></div><!-- fragment --> <table class="doxtable">
<tr>
<th>OPTION </th><th>Description  </th></tr>
<tr>
<td>-d </td><td>Set CMAKE_BUILD_TYPE=Debug (default) </td></tr>
<tr>
<td>-r </td><td>Set CMAKE_BUILD_TYPE=Release </td></tr>
<tr>
<td>-i </td><td>Set CMAKE_BUILD_TYPE=RelWithDebInfo </td></tr>
<tr>
<td>-f </td><td>Set USE_FLOAT=ON (default is USE_FLOAT=OFF) </td></tr>
<tr>
<td>-s </td><td>Set USE_FFTSHIFT=ON (default is USE_FFTSHIFT=OFF) </td></tr>
<tr>
<td>-n </td><td>Do not generate fftw wisdom files </td></tr>
</table>
<p>#### Manually </p><div class="fragment"><div class="line">$ mkdir -p &lt;path/to/build/directory&gt;</div><div class="line">$ cd &lt;path/to/build/directory&gt;</div><div class="line">$ cmake -DCMAKE_BUILD_TYPE=Release -DUSE_FLOAT=OFF &lt;path/to/project/src&gt;</div><div class="line">$ make all -j4</div></div><!-- fragment --><p> Then, generate the FFTW wisdom files using the available CMake target: </p><div class="fragment"><div class="line">$ make fftwisdom</div></div><!-- fragment --><p> Alternatively, the generate_wisdom.sh script can be manually executed (see available options using &ndash;help): </p><div class="fragment"><div class="line">$ cd &lt;path/to/project&gt;/scripts/fftw-wisdom</div><div class="line">$ ./generate_wisdom.sh &lt;OPTIONS&gt;</div></div><!-- fragment --><p> For instance, when compiled in Release mode with -DUSE_FLOAT=ON run: </p><div class="fragment"><div class="line">$ ./generate_wisdom.sh -r -f</div></div><!-- fragment --><p> When executed manually, the wisdom files are written into the wisdomfiles sub-directory created in the working directory.</p>
<h2>Tests Execution</h2>
<p>### Using CMake (after successful build) </p><div class="fragment"><div class="line">$ cd path/to/build/directory</div><div class="line">$ make test</div></div><!-- fragment --><p>### Running on the Command Line (all tests) </p><div class="fragment"><div class="line">$ cd path/to/build/directory</div><div class="line">$ run-parts ./tests</div></div><!-- fragment --><p>## Benchmark Execution </p><div class="fragment"><div class="line">$ cd path/to/build/directory</div><div class="line">$ make benchmarking</div></div><!-- fragment --><p> Note that some benchmarks use the pre-generated FFTW wisdom files by fftw-wisdom tool. Please, be sure to run 'make fftwisdom' before the benchmarks. If in-place fft configuration needs to benchmarked, additional wisdom files must be generated using 'make ifftwisdom'.</p>
<h2>Run STP Executables</h2>
<p>STP provides three executables:</p><ul>
<li>reduce : Runs the entire pipeline (imager and source find stages);</li>
<li>run_imagevis : Runs the imager stage (gridder + FFT + normalisation steps);</li>
<li>run_sourcefind : Runs the source find stage (requires an input image).</li>
</ul>
<p>These executables are located in the build-directory/reduce.</p>
<h3>Reduce</h3>
<p>The pipeline can be executed using: </p><div class="fragment"><div class="line">./reduce [-d] [-l] &lt;input-file-json&gt; &lt;input-file-npz&gt; &lt;output-file-json&gt; &lt;output-file-npz&gt;</div></div><!-- fragment --><table class="doxtable">
<tr>
<th>Argument </th><th>Usage </th><th>Description  </th></tr>
<tr>
<td>&lt;input-file-json&gt; </td><td>required </td><td>Input JSON filename with configuration parameters (e.g. fastimg_oversampling_config.json). </td></tr>
<tr>
<td>&lt;input-file-npz&gt; </td><td>required </td><td>Input NPZ filename with simulation data: uvw_lambda, vis, skymodel (e.g. simdata_nstep10.npz). </td></tr>
<tr>
<td>&lt;output-file-json&gt; </td><td>required </td><td>Output JSON filename for detected islands. </td></tr>
<tr>
<td>&lt;output-file-npz&gt; </td><td>optional </td><td>Output NPZ filename for label map matrix (label_map). </td></tr>
<tr>
<td>-d, &ndash;diff </td><td>optional </td><td>Use residual visibilities - difference between 'input_vis' and 'model' visibilities. </td></tr>
<tr>
<td>-l, &ndash;log </td><td>optional </td><td>Enable logger. </td></tr>
</table>
<p>Example: </p><div class="fragment"><div class="line">$ cd build-directory/reduce</div><div class="line">$ ./reduce fastimg_oversampling_config.json simdata_nstep10.npz detected_islands.json -d -l</div></div><!-- fragment --><p> Note that the provided fastimg_oversampling_config.json file assumes that the pre-generated FFTW wisdom files are located in &lt;build-directory&gt;/wisdomfiles. This is the default path of the FFTW wisdom files when generated by the 'make fftwisdom' command. If a different directory was used, the wisdom file path in the JSON configuration file shall be properly setup.</p>
<h3>Run_imagevis</h3>
<p>The imager can be executed using:</p>
<div class="fragment"><div class="line">./run_imagevis [-d] [-l] &lt;input-file-json&gt; &lt;input-file-npz&gt; &lt;output-file-npz&gt;</div></div><!-- fragment --><table class="doxtable">
<tr>
<th>Argument </th><th>Usage </th><th>Description  </th></tr>
<tr>
<td>&lt;input-file-json&gt; </td><td>required </td><td>Input JSON filename with configuration parameters (e.g. fastimg_oversampling_config.json). </td></tr>
<tr>
<td>&lt;input-file-npz&gt; </td><td>required </td><td>Input NPZ filename with simulation data: uvw_lambda, vis, skymodel (e.g. simdata_nstep10.npz). </td></tr>
<tr>
<td>&lt;output-file-npz&gt; </td><td>optional </td><td>Output NPZ filename for image and beam matrices (image, beam). </td></tr>
<tr>
<td>-d, &ndash;diff </td><td>optional </td><td>Use residual visibilities - difference between 'input_vis' and 'model' visibilities. </td></tr>
<tr>
<td>-l, &ndash;log </td><td>optional </td><td>Enable logger. </td></tr>
</table>
<p>Example: </p><div class="fragment"><div class="line">$ cd build-directory/reduce</div><div class="line">$ ./run_imagevis fastimg_oversampling_config.json simdata_nstep10.npz dirty_image.npz -d -l</div></div><!-- fragment --><h3>Run_sourcefind</h3>
<p>The source find procedure can be executed using:</p>
<div class="fragment"><div class="line">./run_sourcefind  [-l] &lt;input-file-json&gt; &lt;input-file-npz&gt; &lt;output-file-json&gt; &lt;output-file-npz&gt;</div></div><!-- fragment --><table class="doxtable">
<tr>
<th>Argument </th><th>Usage </th><th>Description  </th></tr>
<tr>
<td>&lt;input-file-json&gt; </td><td>required </td><td>Input JSON filename with configuration parameters (e.g. fastimg_oversampling_config.json). </td></tr>
<tr>
<td>&lt;input-file-npz&gt; </td><td>required </td><td>Input NPZ filename with simulation data (image). </td></tr>
<tr>
<td>&lt;output-file-json&gt; </td><td>required </td><td>Output JSON filename for detected islands. </td></tr>
<tr>
<td>&lt;output-file-npz&gt; </td><td>optional </td><td>Output NPZ filename for label map matrix (label_map). </td></tr>
<tr>
<td>-l, &ndash;log </td><td>optional </td><td>Enable logger. </td></tr>
</table>
<p>Example: </p><div class="fragment"><div class="line">$ cd build-directory/reduce</div><div class="line">$ ./run_sourcefind fastimg_oversampling_config.json dirty_image.npz detected_islands.json -l</div></div><!-- fragment --><h2>Run STP using python bindings</h2>
<p>The C++ imager and source find functions of STP can be independently called from Python code, using the STP Python bindings module. The following procedure shall be used:</p><ul>
<li>Import stp_python.so (located in the build directory) and other important modules, such as Numpy.</li>
<li>Setup the variables and load input files required for the wrapper functions.</li>
<li>Call the STP wrapper functions.</li>
</ul>
<p>Example of STP Python bindings that runs the imager and source find functions:</p>
<div class="fragment"><div class="line">import stp_python</div><div class="line">import numpy as np</div><div class="line"></div><div class="line"># Input simdata file must be located in the current directory</div><div class="line">vis_filepath = &#39;simdata_nstep10.npz&#39;</div><div class="line"></div><div class="line"># This example is not computing residual visibilities. &#39;vis&#39; component is directly used as input to the pipeline</div><div class="line">with open(vis_filepath, &#39;rb&#39;) as f:</div><div class="line">    npz_data_dict = np.load(f)</div><div class="line">    uvw_lambda = npz_data_dict[&#39;uvw_lambda&#39;]</div><div class="line">    vis = npz_data_dict[&#39;vis&#39;]</div><div class="line">    vis_weights = npz_data_dict[&#39;snr_weights&#39;]</div><div class="line"></div><div class="line"># Parameters of image_visibilities function</div><div class="line">image_size = 8192</div><div class="line">cell_size = 0.5</div><div class="line">function = stp_python.KernelFunction.GaussianSinc</div><div class="line">support = 3</div><div class="line">trunc = support</div><div class="line">kernel_exact = False</div><div class="line">oversampling = 9</div><div class="line">generate_beam = False</div><div class="line"># Use stp_python.FFTRoutine.FFTW_ESTIMATE_FFT if wisdom files are not available</div><div class="line">r_fft = stp_python.FFTRoutine.FFTW_WISDOM_FFT</div><div class="line"># The FFTW wisdom files must be located in the current directory</div><div class="line">fft_wisdom_filename = &#39;../wisdomfiles/WisdomFile_rob8192x8192.fftw&#39;</div><div class="line"></div><div class="line"># Call image_visibilities</div><div class="line">cpp_img, cpp_beam = stp_python.image_visibilities_wrapper(vis, </div><div class="line">        vis_weights, uvw_lambda, image_size, cell_size, function, </div><div class="line">        trunc, support, kernel_exact, oversampling, generate_beam, </div><div class="line">        r_fft, fft_wisdom_filename)</div><div class="line"></div><div class="line"># Parameters of source_find function</div><div class="line">detection_n_sigma = 50.0</div><div class="line">analysis_n_sigma = 50.0</div><div class="line">rms_est = 0.0</div><div class="line">find_negative = True</div><div class="line">sigma_clip_iters = 5</div><div class="line">median_method = stp_python.MedianMethod.BINAPPROX  </div><div class="line"># Other options: stp_python.MedianMethod.ZEROMEDIAN, stp_python.MedianMethod.BINMEDIAN, stp_python.MedianMethod.NTHELEMENT</div><div class="line">gaussian_fitting = True</div><div class="line">generate_labelmap = False</div><div class="line">ceres_diffmethod = stp_python.CeresDiffMethod.AnalyticDiff_SingleResBlk </div><div class="line"># Other options: stp_python.CeresDiffMethod.AnalyticDiff, stp_python.CeresDiffMethod.AutoDiff_SingleResBlk, stp_python.CeresDiffMethod.AutoDiff</div><div class="line">ceres_solvertype = stp_python.CeresSolverType.LinearSearch_LBFGS </div><div class="line"># Other options: stp_python.CeresSolverType.LinearSearch_BFGS, stp_python.CeresSolverType.TrustRegion_DenseQR</div><div class="line"></div><div class="line"># Call source_find</div><div class="line">islands = stp_python.source_find_wrapper(cpp_img, detection_n_sigma, </div><div class="line">            analysis_n_sigma, rms_est, find_negative, </div><div class="line">            sigma_clip_iters, median_method, gaussian_fitting, </div><div class="line">            generate_labelmap, ceres_diffmethod, ceres_solvertype)</div><div class="line"></div><div class="line"># Print result</div><div class="line">for i in islands:</div><div class="line">   print(i)</div><div class="line">   print()</div></div><!-- fragment --><h2>Run source finding module</h2>
<p>The STP library can be used to run the source finding module independently using either the run_sourcefind executable or calling the stp_python.source_find_wrapper from the Python code, as previously described. However, the input image must satisfy some requirements, in particular, it must be represented using the Double type and use the Fortran-style array order. When these requirements are not meet, it performs an image conversion, which involves copying the entire image to a new array using double type and Fortran-style, degrading the performance of the algorithm.</p>
<p>Thus, for benchmarking purposes, the source finding executable and python bindings must be compiled using the double precision mode and the input image must be represented according to the referred requirements. While using the double type for image representation should not be a problem, since numpy usually uses this type by default, setting the Fortran-style array order may require extra parameters when creating the array. Another solution is to convert the previously created numpy array in C-style to Fortran-style using the np.asfortranarray() function from the Python code.</p>
<h2>Code profiling</h2>
<ul>
<li>Valgrind framework tools can be used to profile STP library: callgrind (function call history and instruction profiling), cachegrind (cache and branch prediction profiling) and massif (memory profiling).</li>
<li>For more accurate profiling STP and reduce shall be compiled in Release mode. However, if detailed profiling of source code lines is desired, debug information shall be added (-g option of gcc). This can be done using the "Release With Debug Information" mode (CMAKE_BUILD_TYPE=RelWithDebInfo), as it uses compiling optimizations while adding debug symbols.</li>
<li>When running valgrind with callgrind tool, add &ndash;separate-threads=yes in order to independently profile all threads.</li>
<li>Results of these tools are written out to a file (default name: &lt;tool&gt;.out.&lt;pid&gt;).</li>
<li>Callgrind and cachegrind output files can be analyzed using kcachegrind GUI application, while massif output file can be analyzed with massif-visualizer.</li>
<li>Callgrind usage example: <div class="fragment"><div class="line">$ cd path/to/build/directory</div><div class="line">$ cd reduce</div><div class="line">$ valgrind --tool=callgrind --separate-threads=yes ./reduce fastimg_oversampling_config.json simdata_nstep10.npz detected_islands.json -d -l</div><div class="line">$ kcachegrind callgrind.out.*</div></div><!-- fragment --> For memory checking purposes, a CMake target for valgrind that executes the test_pipeline_gaussiansinc test is provided: <div class="fragment"><div class="line">$ cd path/to/build/directory</div><div class="line">$ make valgrind</div></div><!-- fragment --> </li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
