<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Slow Transients Pipeline Prototype: /home/lucas/skadev/FastImaging/src/stp/common/ccl.h Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="science_data_processor_logo.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Slow Transients Pipeline Prototype
   </div>
   <div id="projectbrief">Component of the Science Data Processor being developed in the context of the Square Kilometre Array international project, which provides fast snapshot imaging, object detection and cataloguing for the identification of astrophysical image-plane transients.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_71906deff00c706128a95d3938125d0a.html">stp</a></li><li class="navelem"><a class="el" href="dir_3b6b5a7fbb38c0273c9bd069d1271cfa.html">common</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">ccl.h</div>  </div>
</div><!--header-->
<div class="contents">
<a href="ccl_8h.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="preprocessor">#ifndef CCL_H</span></div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;<span class="preprocessor">#define CCL_H</span></div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="preprocessor">#include &quot;../types.h&quot;</span></div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="matstp_8h.html">matstp.h</a>&quot;</span></div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;<span class="preprocessor">#include &lt;armadillo&gt;</span></div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;<span class="preprocessor">#include &lt;cassert&gt;</span></div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;<span class="preprocessor">#include &lt;tbb/tbb.h&gt;</span></div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;<span class="keyword">namespace </span><a class="code" href="namespacestp.html">stp</a> {</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;<span class="comment">// Find the root of the tree of node i.</span></div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;<span class="keyword">inline</span> <span class="keyword">static</span> uint find_root(<span class="keyword">const</span> uint* P, uint i)</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;{</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;    uint root = i;</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;    <span class="keywordflow">while</span> (P[root] &lt; root) {</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;        root = P[root];</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;    }</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;    <span class="keywordflow">return</span> root;</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;}</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;<span class="comment">// Make all nodes in the path of node i point to root.</span></div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;<span class="keyword">inline</span> <span class="keyword">static</span> <span class="keywordtype">void</span> set_root(uint* P, uint i, uint root)</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;{</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;    <span class="keywordflow">while</span> (P[i] &lt; i) {</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;        uint j = P[i];</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;        P[i] = root;</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;        i = j;</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;    }</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;    P[i] = root;</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;}</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;<span class="comment">// Unite the two trees containing nodes i and j and return the new root.</span></div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;<span class="keyword">inline</span> <span class="keyword">static</span> uint set_union(uint* P, uint i, uint j)</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;{</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;    uint root = find_root(P, i);</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;    <span class="keywordflow">if</span> (i != j) {</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;        uint rootj = find_root(P, j);</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;        <span class="keywordflow">if</span> (root &gt; rootj) {</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;            root = rootj;</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;        }</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;        set_root(P, j, root);</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;    }</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;    set_root(P, i, root);</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;    <span class="keywordflow">return</span> root;</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;}</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;</div><div class="line"><a name="l00056"></a><span class="lineno"><a class="line" href="structstp_1_1_label_data_thread.html">   56</a></span>&#160;<span class="keyword">struct </span><a class="code" href="structstp_1_1_label_data_thread.html">LabelDataThread</a> {</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;</div><div class="line"><a name="l00061"></a><span class="lineno"><a class="line" href="structstp_1_1_label_data_thread.html#afd42a0cb27b1c61f7957a3335eb9d3eb">   61</a></span>&#160;    <a class="code" href="structstp_1_1_label_data_thread.html#afd42a0cb27b1c61f7957a3335eb9d3eb">LabelDataThread</a>()</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;        : <a class="code" href="structstp_1_1_label_data_thread.html#af036d19b43cbc62e34b9c29c2f328c46">col_start</a>(0)</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;        , <a class="code" href="structstp_1_1_label_data_thread.html#afd40a928873f6544aeb7aa23a74f9e9b">lunique_start</a>(0)</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;        , <a class="code" href="structstp_1_1_label_data_thread.html#aa8081e2d6b14913c764c80b592404130">lunique_p</a>(0)</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;        , <a class="code" href="structstp_1_1_label_data_thread.html#aed514e2fce63ea5947eeb34dbb4f53df">lunique_n</a>(0)</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;    {</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;    }</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;</div><div class="line"><a name="l00072"></a><span class="lineno"><a class="line" href="structstp_1_1_label_data_thread.html#ade599105640ff8996e8691aafc49247f">   72</a></span>&#160;    <a class="code" href="structstp_1_1_label_data_thread.html#ade599105640ff8996e8691aafc49247f">LabelDataThread</a>(uint in_col_start, uint in_lunique_start, uint in_lunique_p, uint in_lunique_n)</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;        : <a class="code" href="structstp_1_1_label_data_thread.html#af036d19b43cbc62e34b9c29c2f328c46">col_start</a>(in_col_start)</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;        , <a class="code" href="structstp_1_1_label_data_thread.html#afd40a928873f6544aeb7aa23a74f9e9b">lunique_start</a>(in_lunique_start)</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;        , <a class="code" href="structstp_1_1_label_data_thread.html#aa8081e2d6b14913c764c80b592404130">lunique_p</a>(in_lunique_p)</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;        , <a class="code" href="structstp_1_1_label_data_thread.html#aed514e2fce63ea5947eeb34dbb4f53df">lunique_n</a>(in_lunique_n)</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;    {</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;    }</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;</div><div class="line"><a name="l00080"></a><span class="lineno"><a class="line" href="structstp_1_1_label_data_thread.html#af036d19b43cbc62e34b9c29c2f328c46">   80</a></span>&#160;    uint <a class="code" href="structstp_1_1_label_data_thread.html#af036d19b43cbc62e34b9c29c2f328c46">col_start</a>;</div><div class="line"><a name="l00081"></a><span class="lineno"><a class="line" href="structstp_1_1_label_data_thread.html#afd40a928873f6544aeb7aa23a74f9e9b">   81</a></span>&#160;    uint <a class="code" href="structstp_1_1_label_data_thread.html#afd40a928873f6544aeb7aa23a74f9e9b">lunique_start</a>;</div><div class="line"><a name="l00082"></a><span class="lineno"><a class="line" href="structstp_1_1_label_data_thread.html#aa8081e2d6b14913c764c80b592404130">   82</a></span>&#160;    uint <a class="code" href="structstp_1_1_label_data_thread.html#aa8081e2d6b14913c764c80b592404130">lunique_p</a>;</div><div class="line"><a name="l00083"></a><span class="lineno"><a class="line" href="structstp_1_1_label_data_thread.html#aed514e2fce63ea5947eeb34dbb4f53df">   83</a></span>&#160;    uint <a class="code" href="structstp_1_1_label_data_thread.html#aed514e2fce63ea5947eeb34dbb4f53df">lunique_n</a>;</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;};</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;<span class="keyword">template</span> &lt;<span class="keywordtype">bool</span> findNegative&gt;</div><div class="line"><a name="l00106"></a><span class="lineno"><a class="line" href="namespacestp.html#af25487cd82119504b148bd619af82062">  106</a></span>&#160;std::tuple&lt;MatStp&lt;int&gt;, <a class="code" href="classstp_1_1_mat_stp.html">MatStp&lt;uint&gt;</a>, uint, uint&gt; <a class="code" href="namespacestp.html#af25487cd82119504b148bd619af82062">labeling</a>(<span class="keyword">const</span> arma::Mat&lt;real_t&gt;&amp; I, <span class="keyword">const</span> <a class="code" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> analysis_thresh_pos, <span class="keyword">const</span> <a class="code" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> analysis_thresh_neg)</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;{</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;    <span class="keyword">const</span> <span class="keywordtype">size_t</span> cols = I.n_cols;</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;    <span class="keyword">const</span> <span class="keywordtype">size_t</span> rows = I.n_rows;</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;<span class="preprocessor">#ifndef FFTSHIFT</span></div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;    <span class="keyword">const</span> <span class="keywordtype">size_t</span> cshift = cols / 2;</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;    <span class="keyword">const</span> <span class="keywordtype">size_t</span> rshift = rows / 2;</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;    assert(cols &lt;= 65536);</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;    assert(rows &lt;= 65536);</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;    <span class="comment">// Assert cols and rows are power of two</span></div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;    assert(!(cols &amp; (cols - 1)));</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;    assert(!(rows &amp; (rows - 1)));</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;    <span class="comment">// Use MapStp because L (label map) shall be initialized with zeroes</span></div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;    <a class="code" href="classstp_1_1_mat_stp.html">MatStp&lt;int&gt;</a> L(I.n_rows, I.n_cols);</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;    <span class="comment">// A quick and dirty upper bound for the maximimum number of labels.</span></div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;    <span class="keyword">const</span> <span class="keywordtype">size_t</span> Plength = cols * rows / 2;</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;    assert(Plength &gt; cols);</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;    uint Pcols = 1;</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;    <span class="keywordflow">if</span> (findNegative) {</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;        Pcols = 2;</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;    }</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;    <span class="comment">// Array of decision tree</span></div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;    MatStp&lt;uint&gt; P(Plength, Pcols);</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;    uint* Pp = (uint*)P.colptr(0);</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;    uint* Pn = (uint*)P.colptr(Pcols - 1);</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;    <span class="comment">// Define maximum number of slices based on the number of available threads</span></div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;    uint max_num_slices = tbb::task_scheduler_init::default_num_threads() * 8;</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;    uint num_slices = 1;</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;    <span class="keywordflow">while</span> (num_slices &lt; max_num_slices) {</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;        num_slices *= 2;</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;        <span class="keywordflow">if</span> ((cols / num_slices) &lt; num_slices) {</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;            <span class="keywordflow">break</span>;</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;        }</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;        <span class="comment">// Cols must be divisible by the number of chunks</span></div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;        <span class="keywordflow">if</span> ((cols % num_slices) != 0) {</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;            <span class="keywordflow">break</span>;</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;        }</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;    }</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;    num_slices /= 2;</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;    assert(cols % num_slices == 0);</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;    <span class="comment">// Grain size</span></div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;    <span class="keywordtype">size_t</span> grainsize = cols / num_slices;</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;    <span class="comment">// Use this vector to store start column and number of labels assigned by each thread</span></div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;    tbb::concurrent_vector&lt;LabelDataThread&gt; label_data_per_thread(num_slices);</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;    <span class="comment">// Scanning phase</span></div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;    <span class="comment">// Use static partitioner because image partitions need to be known in the next step of border merging</span></div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;    tbb::parallel_for(tbb::blocked_range&lt;size_t&gt;(0, cols, grainsize), [&amp;](<span class="keyword">const</span> tbb::blocked_range&lt;size_t&gt;&amp; r) {</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;        <span class="keyword">const</span> uint <a class="code" href="structstp_1_1_label_data_thread.html#afd40a928873f6544aeb7aa23a74f9e9b">lunique_start</a> = (r.begin() * (rows / 2));</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;        Pp[<a class="code" href="structstp_1_1_label_data_thread.html#afd40a928873f6544aeb7aa23a74f9e9b">lunique_start</a>] = 0;</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;        Pn[<a class="code" href="structstp_1_1_label_data_thread.html#afd40a928873f6544aeb7aa23a74f9e9b">lunique_start</a>] = 0;</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;        assert(lunique_start &lt; (cols * rows / 2));</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;        uint <a class="code" href="structstp_1_1_label_data_thread.html#aa8081e2d6b14913c764c80b592404130">lunique_p</a> = lunique_start + 1;</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;        uint <a class="code" href="structstp_1_1_label_data_thread.html#aed514e2fce63ea5947eeb34dbb4f53df">lunique_n</a> = lunique_start + 1;</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;        assert(lunique_p &gt;= 0);</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;        assert(lunique_n &gt;= 0);</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;        <span class="keyword">const</span> uint <a class="code" href="structstp_1_1_label_data_thread.html#af036d19b43cbc62e34b9c29c2f328c46">col_start</a> = r.begin();</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;        <span class="keyword">const</span> uint col_end = r.end();</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;        <span class="keywordflow">for</span> (uint c_i = col_start; c_i &lt; col_end; ++c_i) {</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;<span class="preprocessor">#ifdef FFTSHIFT</span></div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;            <span class="keyword">const</span> uint m_c_i = c_i;</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;            uint m_c_i_prev = (m_c_i == 0) ? m_c_i : m_c_i - 1;</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;<span class="preprocessor">#else</span></div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;            <span class="keyword">const</span> uint m_c_i = c_i &gt;= cshift ? c_i - cshift : c_i + cshift;</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;            uint m_c_i_prev = (m_c_i == 0) ? cols - 1 : m_c_i - 1;</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;            assert(m_c_i &lt; cols);</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;            assert(m_c_i_prev &lt; cols);</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;            <span class="keywordtype">int</span>* Lcol = L.colptr(m_c_i);</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;            <span class="keywordtype">int</span>* Lcol_prev = L.colptr(m_c_i_prev);</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;            <span class="keyword">const</span> <a class="code" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a>* Icol = I.colptr(m_c_i);</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;            <span class="comment">// Indicate whether the left neighbor is valid or not (it is not valid for the first column of each thread)</span></div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;            <span class="keyword">const</span> <span class="keywordtype">bool</span> T_left_valid = !(c_i == r.begin());</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;            <span class="keywordflow">for</span> (uint m_r_i = 0; m_r_i &lt; rows; m_r_i++) {</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;                assert(m_r_i &lt; rows);</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;                <span class="keywordflow">if</span> (*(Icol + m_r_i) &gt; analysis_thresh_pos) {</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;                    <span class="keyword">const</span> uint m_r_i_prev = (m_r_i == 0) ? m_r_i : m_r_i - 1;</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;                    <span class="keywordtype">int</span>* curL = Lcol + m_r_i;</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;                    <span class="keyword">const</span> <span class="keywordtype">int</span> top_pix = *(Lcol + m_r_i_prev);</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;                    <span class="keyword">const</span> <span class="keywordtype">int</span> left_pix = *(Lcol_prev + m_r_i);</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;                    <span class="comment">// Indicate if it is connected to left pixel</span></div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;                    <span class="keyword">const</span> <span class="keywordtype">bool</span> T_left = T_left_valid &amp;&amp; (left_pix &gt; 0);</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;<span class="preprocessor">#ifdef FFTSHIFT</span></div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;                    <span class="comment">// Indicate if it is connected to top pixel</span></div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;                    <span class="keyword">const</span> <span class="keywordtype">bool</span> T_top = (m_r_i == 0) ? <span class="keyword">false</span> : (top_pix &gt; 0);</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;<span class="preprocessor">#else</span></div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;                    <span class="comment">// Indicate if it is connected to top pixel</span></div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;                    <span class="keyword">const</span> <span class="keywordtype">bool</span> T_top = (m_r_i == rshift || m_r_i == 0) ? <span class="keyword">false</span> : (top_pix &gt; 0);</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;                    <span class="keywordflow">if</span> (T_left) {</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;                        <span class="keywordflow">if</span> (T_top) {</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;                            <span class="comment">// copy(top, left)</span></div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;                            *curL = set_union(Pp, top_pix, left_pix);</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;                        } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;                            <span class="comment">// copy(left)</span></div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;                            *curL = left_pix;</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;                        }</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;                    } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;                        <span class="keywordflow">if</span> (T_top) {</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;                            <span class="comment">// copy(top)</span></div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;                            *curL = top_pix;</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;                        } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;                            <span class="comment">// new label</span></div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;                            *curL = <a class="code" href="structstp_1_1_label_data_thread.html#aa8081e2d6b14913c764c80b592404130">lunique_p</a>;</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;                            Pp[<a class="code" href="structstp_1_1_label_data_thread.html#aa8081e2d6b14913c764c80b592404130">lunique_p</a>] = <a class="code" href="structstp_1_1_label_data_thread.html#aa8081e2d6b14913c764c80b592404130">lunique_p</a>;</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;                            lunique_p = lunique_p + 1;</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;                        }</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;                    }</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;                } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;                    <span class="comment">// Negative sources</span></div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;                    <span class="keywordflow">if</span> (findNegative &amp;&amp; (*(Icol + m_r_i) &lt; analysis_thresh_neg)) {</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;                        <span class="keyword">const</span> uint m_r_i_prev = (m_r_i == 0) ? m_r_i : m_r_i - 1;</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;                        <span class="keywordtype">int</span>* curL = Lcol + m_r_i;</div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;                        <span class="keyword">const</span> <span class="keywordtype">int</span> top_pix = *(Lcol + m_r_i_prev);</div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;                        <span class="keyword">const</span> <span class="keywordtype">int</span> left_pix = *(Lcol_prev + m_r_i);</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;                        <span class="comment">// Indicate if it is connected to left pixel</span></div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;                        <span class="keyword">const</span> <span class="keywordtype">bool</span> T_left = T_left_valid &amp;&amp; (left_pix &lt; 0);</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;<span class="preprocessor">#ifdef FFTSHIFT</span></div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;                        <span class="comment">// Indicate if it is connected to top pixel</span></div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;                        <span class="keyword">const</span> <span class="keywordtype">bool</span> T_top = (m_r_i == 0) ? <span class="keyword">false</span> : (top_pix &lt; 0);</div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;<span class="preprocessor">#else</span></div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;                        <span class="comment">// Indicate if it is connected to top pixel</span></div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;                        <span class="keyword">const</span> <span class="keywordtype">bool</span> T_top = (m_r_i == rshift || m_r_i == 0) ? <span class="keyword">false</span> : (top_pix &lt; 0);</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;                        <span class="keywordflow">if</span> (T_left) {</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;                            <span class="keywordflow">if</span> (T_top) {</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;                                <span class="comment">// copy(top, left)</span></div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;                                *curL = set_union(Pn, -top_pix, -left_pix) * (-1);</div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;                            } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;                                <span class="comment">// copy(left)</span></div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;                                *curL = left_pix;</div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;                            }</div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;                        } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;                            <span class="keywordflow">if</span> (T_top) {</div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;                                <span class="comment">// copy(top)</span></div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;                                *curL = top_pix;</div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;                            } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;                                <span class="comment">// new label</span></div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;                                *curL = -<a class="code" href="structstp_1_1_label_data_thread.html#aed514e2fce63ea5947eeb34dbb4f53df">lunique_n</a>;</div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;                                Pn[<a class="code" href="structstp_1_1_label_data_thread.html#aed514e2fce63ea5947eeb34dbb4f53df">lunique_n</a>] = <a class="code" href="structstp_1_1_label_data_thread.html#aed514e2fce63ea5947eeb34dbb4f53df">lunique_n</a>;</div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;                                lunique_n = lunique_n + 1;</div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;                            }</div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;                        }</div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;                    }</div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;                }</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;            }</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;</div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;<span class="preprocessor">#ifndef FFTSHIFT</span></div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;            <span class="comment">// ROW BORDER MERGING (top and bottom matrix margins)</span></div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;            <span class="comment">// Performs border merging between the first and last rows of the matrix</span></div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;            <span class="keyword">const</span> uint m_r_i = 0;</div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;            <span class="keyword">const</span> uint m_r_i_prev = rows - 1;</div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;            <span class="keywordtype">int</span>* curL = Lcol + m_r_i;</div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;            <span class="keywordflow">if</span> (*curL &gt; 0) {</div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;                <span class="keyword">const</span> <span class="keywordtype">int</span> top_pix = *(Lcol + m_r_i_prev);</div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;                <span class="keywordflow">if</span> (top_pix &gt; 0) {</div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;                    *curL = set_union(Pp, *curL, top_pix);</div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;                }</div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;            } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;                <span class="keywordflow">if</span> (findNegative &amp;&amp; (*curL &lt; 0)) {</div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;                    <span class="keyword">const</span> <span class="keywordtype">int</span> top_pix = *(Lcol + m_r_i_prev);</div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;                    <span class="keywordflow">if</span> (top_pix &lt; 0) {</div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;                        *curL = set_union(Pn, -(*curL), -top_pix) * (-1);</div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;                    }</div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;                }</div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;            }</div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;        }</div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;        uint idx = col_start / (grainsize);</div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;        label_data_per_thread[idx] = <a class="code" href="structstp_1_1_label_data_thread.html#afd42a0cb27b1c61f7957a3335eb9d3eb">LabelDataThread</a>(col_start, lunique_start, lunique_p, lunique_n);</div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;    },</div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;        tbb::static_partitioner());</div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;</div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;    <span class="comment">// COLUMN BORDER MERGING</span></div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;    <span class="comment">// Merges the matrix left and right borders as well as all the partitioned regions required for parallel processing</span></div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp;&amp; r : label_data_per_thread) {</div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;        uint c_i = r.col_start;</div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;<span class="preprocessor">#ifdef FFTSHIFT</span></div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;        <span class="keyword">const</span> uint m_c_i = c_i;</div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;        uint m_c_i_prev = m_c_i == 0 ? m_c_i : m_c_i - 1;</div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;<span class="preprocessor">#else</span></div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;        <span class="keyword">const</span> uint m_c_i = c_i &gt;= cshift ? c_i - cshift : c_i + cshift;</div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;        uint m_c_i_prev = m_c_i == 0 ? cols - 1 : m_c_i - 1;</div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;        assert(m_c_i &lt; cols);</div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;        assert(m_c_i_prev &lt; cols);</div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;</div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;        <span class="keywordtype">int</span>* <span class="keyword">const</span> Lcol = L.colptr(m_c_i);</div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;        <span class="keywordtype">int</span>* <span class="keyword">const</span> Lcol_prev = L.colptr(m_c_i_prev);</div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;</div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;        <span class="keyword">const</span> <span class="keywordtype">bool</span> T_left_valid = c_i != 0;</div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;        <span class="keywordflow">for</span> (uint m_r_i = 0; m_r_i &lt; rows; m_r_i++) {</div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;            <span class="keywordtype">int</span>* curL = Lcol + m_r_i;</div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;            <span class="keyword">const</span> <span class="keywordtype">int</span> cur_pix = *curL;</div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;            <span class="keywordflow">if</span> (cur_pix &gt; 0) {</div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;                <span class="keyword">const</span> <span class="keywordtype">int</span> left_pix = *(Lcol_prev + m_r_i);</div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;                <span class="keywordflow">if</span> (T_left_valid &amp;&amp; (left_pix &gt; 0)) {</div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;                    *curL = set_union(Pp, cur_pix, left_pix);</div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;                }</div><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;            } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;                <span class="keywordflow">if</span> (findNegative &amp;&amp; (cur_pix &lt; 0)) {</div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;                    <span class="keyword">const</span> <span class="keywordtype">int</span> left_pix = *(Lcol_prev + m_r_i);</div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;                    <span class="keywordflow">if</span> (T_left_valid &amp;&amp; (left_pix &lt; 0)) {</div><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;                        *curL = set_union(Pn, -cur_pix, -left_pix) * (-1);</div><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;                    }</div><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;                }</div><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;            }</div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;        }</div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;    }</div><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;</div><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;    <span class="comment">// Analysis: positive sources</span></div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;    uint k = 1;</div><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp;&amp; r : label_data_per_thread) {</div><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;        <span class="keywordflow">for</span> (uint i = r.lunique_start + 1; i &lt; r.lunique_p; ++i) {</div><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;            <span class="keywordflow">if</span> (Pp[i] &lt; i) {</div><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;                Pp[i] = Pp[Pp[i]];</div><div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;            } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;                Pp[i] = k;</div><div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;                k = k + 1;</div><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;            }</div><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;        }</div><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;    }</div><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;    <span class="keyword">const</span> uint num_l_pos = k - 1;</div><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;</div><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;    <span class="comment">// Analysis: negative sources</span></div><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;    k = 1;</div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;    <span class="keywordflow">if</span> (findNegative) {</div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp;&amp; r : label_data_per_thread) {</div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;            <span class="keywordflow">for</span> (uint i = r.lunique_start + 1; i &lt; r.lunique_n; ++i) {</div><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;                <span class="keywordflow">if</span> (Pn[i] &lt; i) {</div><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;                    Pn[i] = Pn[Pn[i]];</div><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;                } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;                    Pn[i] = k;</div><div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;                    k = k + 1;</div><div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;                }</div><div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;            }</div><div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;        }</div><div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;    }</div><div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;    <span class="keyword">const</span> uint num_l_neg = k - 1;</div><div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;</div><div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;    <span class="comment">// Return label map (temporary labels), array of decision tree, number of positive and negative labels</span></div><div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;    <span class="keywordflow">return</span> std::make_tuple(std::move(L), std::move(P), num_l_pos, num_l_neg);</div><div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;}</div><div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;}</div><div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;</div><div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;<span class="preprocessor">#endif </span><span class="comment">/* CCL_H */</span><span class="preprocessor"></span></div><div class="ttc" id="structstp_1_1_label_data_thread_html"><div class="ttname"><a href="structstp_1_1_label_data_thread.html">stp::LabelDataThread</a></div><div class="ttdoc">LabelDataThread struct is used to store start column and detected label information of a thread...</div><div class="ttdef"><b>Definition:</b> ccl.h:56</div></div>
<div class="ttc" id="structstp_1_1_label_data_thread_html_aed514e2fce63ea5947eeb34dbb4f53df"><div class="ttname"><a href="structstp_1_1_label_data_thread.html#aed514e2fce63ea5947eeb34dbb4f53df">stp::LabelDataThread::lunique_n</a></div><div class="ttdeci">uint lunique_n</div><div class="ttdef"><b>Definition:</b> ccl.h:83</div></div>
<div class="ttc" id="structstp_1_1_label_data_thread_html_ade599105640ff8996e8691aafc49247f"><div class="ttname"><a href="structstp_1_1_label_data_thread.html#ade599105640ff8996e8691aafc49247f">stp::LabelDataThread::LabelDataThread</a></div><div class="ttdeci">LabelDataThread(uint in_col_start, uint in_lunique_start, uint in_lunique_p, uint in_lunique_n)</div><div class="ttdoc">LabelDataThread constructor. </div><div class="ttdef"><b>Definition:</b> ccl.h:72</div></div>
<div class="ttc" id="classstp_1_1_mat_stp_html"><div class="ttname"><a href="classstp_1_1_mat_stp.html">stp::MatStp</a></div><div class="ttdoc">The MatStp matrix class. </div><div class="ttdef"><b>Definition:</b> matstp.h:92</div></div>
<div class="ttc" id="structstp_1_1_label_data_thread_html_af036d19b43cbc62e34b9c29c2f328c46"><div class="ttname"><a href="structstp_1_1_label_data_thread.html#af036d19b43cbc62e34b9c29c2f328c46">stp::LabelDataThread::col_start</a></div><div class="ttdeci">uint col_start</div><div class="ttdef"><b>Definition:</b> ccl.h:80</div></div>
<div class="ttc" id="structstp_1_1_label_data_thread_html_afd42a0cb27b1c61f7957a3335eb9d3eb"><div class="ttname"><a href="structstp_1_1_label_data_thread.html#afd42a0cb27b1c61f7957a3335eb9d3eb">stp::LabelDataThread::LabelDataThread</a></div><div class="ttdeci">LabelDataThread()</div><div class="ttdoc">LabelDataThread default constructor. </div><div class="ttdef"><b>Definition:</b> ccl.h:61</div></div>
<div class="ttc" id="namespacestp_html"><div class="ttname"><a href="namespacestp.html">stp</a></div><div class="ttdef"><b>Definition:</b> ccl.cpp:17</div></div>
<div class="ttc" id="namespacestp_html_af25487cd82119504b148bd619af82062"><div class="ttname"><a href="namespacestp.html#af25487cd82119504b148bd619af82062">stp::labeling</a></div><div class="ttdeci">std::tuple&lt; MatStp&lt; int &gt;, MatStp&lt; uint &gt;, uint, uint &gt; labeling(const arma::Mat&lt; real_t &gt; &amp;I, const real_t analysis_thresh_pos, const real_t analysis_thresh_neg)</div><div class="ttdoc">Performs the connected components labeling (CCL) algorithm using 4-connectivity. </div><div class="ttdef"><b>Definition:</b> ccl.h:106</div></div>
<div class="ttc" id="structstp_1_1_label_data_thread_html_aa8081e2d6b14913c764c80b592404130"><div class="ttname"><a href="structstp_1_1_label_data_thread.html#aa8081e2d6b14913c764c80b592404130">stp::LabelDataThread::lunique_p</a></div><div class="ttdeci">uint lunique_p</div><div class="ttdef"><b>Definition:</b> ccl.h:82</div></div>
<div class="ttc" id="matstp_8h_html"><div class="ttname"><a href="matstp_8h.html">matstp.h</a></div><div class="ttdoc">MatStp matrix class. </div></div>
<div class="ttc" id="types_8h_html_ab46614359717672dc9a4eed4669be6e6"><div class="ttname"><a href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a></div><div class="ttdeci">double real_t</div><div class="ttdef"><b>Definition:</b> types.h:16</div></div>
<div class="ttc" id="structstp_1_1_label_data_thread_html_afd40a928873f6544aeb7aa23a74f9e9b"><div class="ttname"><a href="structstp_1_1_label_data_thread.html#afd40a928873f6544aeb7aa23a74f9e9b">stp::LabelDataThread::lunique_start</a></div><div class="ttdeci">uint lunique_start</div><div class="ttdef"><b>Definition:</b> ccl.h:81</div></div>
</div><!-- fragment --></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
