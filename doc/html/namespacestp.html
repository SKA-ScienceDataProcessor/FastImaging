<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Slow Transients Pipeline Prototype: stp Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="science_data_processor_logo.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Slow Transients Pipeline Prototype
   </div>
   <div id="projectbrief">Component of the Science Data Processor being developed in the context of the Square Kilometre Array international project, which provides fast snapshot imaging, object detection and cataloguing for the identification of astrophysical image-plane transients.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">stp Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstp_1_1_bounding_box.html">BoundingBox</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents bounding box positions: top, bottom, left and right margins.  <a href="structstp_1_1_bounding_box.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstp_1_1_data_stats.html">DataStats</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct that stores computed statistics: mean, sigma, median.  <a href="structstp_1_1_data_stats.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstp_1_1_double_pair.html">DoublePair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct that stores a pair of doubles.  <a href="structstp_1_1_double_pair.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionstp_1_1_float_twiddler.html">FloatTwiddler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a floation-point number that can be accessed using the integer type. This union allows to perform bitwise operations using the integer type interface.  <a href="unionstp_1_1_float_twiddler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstp_1_1_gaussian.html">Gaussian</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classstp_1_1_gaussian.html" title="The Gaussian functor class. ">Gaussian</a> functor class.  <a href="classstp_1_1_gaussian.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstp_1_1_gaussian2d_fit.html">Gaussian2dFit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structstp_1_1_gaussian2d_fit.html" title="The Gaussian2dFit struct. ">Gaussian2dFit</a> struct.  <a href="structstp_1_1_gaussian2d_fit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstp_1_1_gaussian_all_residuals.html">GaussianAllResiduals</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor that computes all residuals between source data and 2D gaussian model.  <a href="classstp_1_1_gaussian_all_residuals.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstp_1_1_gaussian_analytic.html">GaussianAnalytic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes residual and jacobian on the given point x,y for gaussian fitting using analytic derivatives.  <a href="classstp_1_1_gaussian_analytic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstp_1_1_gaussian_analytic_all_residuals.html">GaussianAnalyticAllResiduals</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes all source residuals and jacobians for gaussian fitting using analytic derivatives.  <a href="classstp_1_1_gaussian_analytic_all_residuals.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstp_1_1_gaussian_residual.html">GaussianResidual</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor that computes the residual on the given point x,y between source data and 2D gaussian model.  <a href="classstp_1_1_gaussian_residual.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstp_1_1_gaussian_sinc.html">GaussianSinc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classstp_1_1_gaussian_sinc.html" title="The GaussianSinc functor class. ">GaussianSinc</a> functor class.  <a href="classstp_1_1_gaussian_sinc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstp_1_1_gridder_output.html">GridderOutput</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The gridder output class.  <a href="classstp_1_1_gridder_output.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstp_1_1_island_params.html">IslandParams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structstp_1_1_island_params.html" title="IslandParams struct. ">IslandParams</a> struct.  <a href="structstp_1_1_island_params.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstp_1_1_label_data_thread.html">LabelDataThread</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structstp_1_1_label_data_thread.html" title="LabelDataThread struct is used to store start column and detected label information of a thread...">LabelDataThread</a> struct is used to store start column and detected label information of a thread.  <a href="structstp_1_1_label_data_thread.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstp_1_1_mat_stp.html">MatStp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classstp_1_1_mat_stp.html" title="The MatStp matrix class. ">MatStp</a> matrix class.  <a href="classstp_1_1_mat_stp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstp_1_1_sinc.html">Sinc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classstp_1_1_sinc.html" title="The Sinc functor class. ">Sinc</a> functor class.  <a href="classstp_1_1_sinc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstp_1_1_source_find_image.html">SourceFindImage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classstp_1_1_source_find_image.html" title="The SourceFindImage class for source detection. ">SourceFindImage</a> class for source detection.  <a href="classstp_1_1_source_find_image.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstp_1_1_top_hat.html">TopHat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classstp_1_1_top_hat.html" title="The TopHat functor class. ">TopHat</a> functor class.  <a href="classstp_1_1_top_hat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstp_1_1_triangle.html">Triangle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classstp_1_1_triangle.html" title="The Triangle functor class. ">Triangle</a> functor class.  <a href="classstp_1_1_triangle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstp_1_1_zero_mem_alloc.html">ZeroMemAlloc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classstp_1_1_zero_mem_alloc.html" title="The ZeroMemAlloc buffer class. ">ZeroMemAlloc</a> buffer class.  <a href="classstp_1_1_zero_mem_alloc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a92421a2e1781ba7c1263b57c12082d58"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestp.html#a92421a2e1781ba7c1263b57c12082d58">KernelFunction</a> { <br />
&#160;&#160;<a class="el" href="namespacestp.html#a92421a2e1781ba7c1263b57c12082d58acd678285c2431c505ac62192462e0b04">KernelFunction::TopHat</a>, 
<a class="el" href="namespacestp.html#a92421a2e1781ba7c1263b57c12082d58a5e5500cb2b82eb72d550de644bd1b64b">KernelFunction::Triangle</a>, 
<a class="el" href="namespacestp.html#a92421a2e1781ba7c1263b57c12082d58a43e79bd61fa47e2cbc202a93f921c406">KernelFunction::Sinc</a>, 
<a class="el" href="namespacestp.html#a92421a2e1781ba7c1263b57c12082d58afedf7ba6075fb5526a7ace0b9385528d">KernelFunction::Gaussian</a>, 
<br />
&#160;&#160;<a class="el" href="namespacestp.html#a92421a2e1781ba7c1263b57c12082d58a74fa5da616c7dcd36f467abc96241471">KernelFunction::GaussianSinc</a>
<br />
 }<tr class="memdesc:a92421a2e1781ba7c1263b57c12082d58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum of available kernel functions.  <a href="namespacestp.html#a92421a2e1781ba7c1263b57c12082d58">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a92421a2e1781ba7c1263b57c12082d58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a464d541245c3d8f9ea82f5d2d5484c98"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestp.html#a464d541245c3d8f9ea82f5d2d5484c98">FFTRoutine</a> { <br />
&#160;&#160;<a class="el" href="namespacestp.html#a464d541245c3d8f9ea82f5d2d5484c98a1551a8f00e3ff5f46b18636fb963ad8c">FFTRoutine::FFTW_ESTIMATE_FFT</a>, 
<a class="el" href="namespacestp.html#a464d541245c3d8f9ea82f5d2d5484c98a5b1699ed6ddd9a9360937797edfe3873">FFTRoutine::FFTW_MEASURE_FFT</a>, 
<a class="el" href="namespacestp.html#a464d541245c3d8f9ea82f5d2d5484c98af7b85ceb556fa3fccee760843b070ceb">FFTRoutine::FFTW_PATIENT_FFT</a>, 
<a class="el" href="namespacestp.html#a464d541245c3d8f9ea82f5d2d5484c98ab6cc625b02ae42496e8baea63abf1243">FFTRoutine::FFTW_WISDOM_FFT</a>, 
<br />
&#160;&#160;<a class="el" href="namespacestp.html#a464d541245c3d8f9ea82f5d2d5484c98ac68eed57a11ce9105b7e0355d5b2e84d">FFTRoutine::FFTW_WISDOM_INPLACE_FFT</a>
<br />
 }<tr class="memdesc:a464d541245c3d8f9ea82f5d2d5484c98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum of available FFT algorithms.  <a href="namespacestp.html#a464d541245c3d8f9ea82f5d2d5484c98">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a464d541245c3d8f9ea82f5d2d5484c98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30ea75fc2a28e18b48e3a9939e3760a9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestp.html#a30ea75fc2a28e18b48e3a9939e3760a9">CeresDiffMethod</a> { <a class="el" href="namespacestp.html#a30ea75fc2a28e18b48e3a9939e3760a9ae8967ede587723717837909c3712390e">CeresDiffMethod::AutoDiff</a>, 
<a class="el" href="namespacestp.html#a30ea75fc2a28e18b48e3a9939e3760a9a4db6200d2a3fb2b994ff83a49c99a6d4">CeresDiffMethod::AutoDiff_SingleResBlk</a>, 
<a class="el" href="namespacestp.html#a30ea75fc2a28e18b48e3a9939e3760a9accc88f7642b52779190d6a143d1a8fe7">CeresDiffMethod::AnalyticDiff</a>, 
<a class="el" href="namespacestp.html#a30ea75fc2a28e18b48e3a9939e3760a9a22112738903c086da2e47ba0dc8f8d9e">CeresDiffMethod::AnalyticDiff_SingleResBlk</a>
 }<tr class="memdesc:a30ea75fc2a28e18b48e3a9939e3760a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum of available differentiation methods used by ceres library for gaussian fitting.  <a href="namespacestp.html#a30ea75fc2a28e18b48e3a9939e3760a9">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a30ea75fc2a28e18b48e3a9939e3760a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae604b01190a3a3414720a85c806fd7d6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestp.html#ae604b01190a3a3414720a85c806fd7d6">CeresSolverType</a> { <a class="el" href="namespacestp.html#ae604b01190a3a3414720a85c806fd7d6afd0d5b1f6ee7757ec90dce1107dcef00">CeresSolverType::LinearSearch_BFGS</a>, 
<a class="el" href="namespacestp.html#ae604b01190a3a3414720a85c806fd7d6a25f51874b6aac8fb933c164f9d42778c">CeresSolverType::LinearSearch_LBFGS</a>, 
<a class="el" href="namespacestp.html#ae604b01190a3a3414720a85c806fd7d6a4d89de3a5b02f9f6f445cbe2358a8675">CeresSolverType::TrustRegion_DenseQR</a>
 }<tr class="memdesc:ae604b01190a3a3414720a85c806fd7d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum of available solver types used by ceres library for gaussian fitting.  <a href="namespacestp.html#ae604b01190a3a3414720a85c806fd7d6">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ae604b01190a3a3414720a85c806fd7d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af25487cd82119504b148bd619af82062"><td class="memTemplParams" colspan="2">template&lt;bool findNegative&gt; </td></tr>
<tr class="memitem:af25487cd82119504b148bd619af82062"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="classstp_1_1_mat_stp.html">MatStp</a>&lt; int &gt;, <a class="el" href="classstp_1_1_mat_stp.html">MatStp</a>&lt; uint &gt;, uint, uint &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestp.html#af25487cd82119504b148bd619af82062">labeling</a> (const arma::Mat&lt; <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> &gt; &amp;I, const <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> analysis_thresh_pos, const <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> analysis_thresh_neg)</td></tr>
<tr class="memdesc:af25487cd82119504b148bd619af82062"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the connected components labeling (CCL) algorithm using 4-connectivity.  <a href="#af25487cd82119504b148bd619af82062">More...</a><br /></td></tr>
<tr class="separator:af25487cd82119504b148bd619af82062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4af482cb10c30fd252b434dd0aef3074"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestp.html#a4af482cb10c30fd252b434dd0aef3074">fft_fftw_c2r</a> (arma::Mat&lt; <a class="el" href="types_8h.html#a1d2a57e59f061705d305d324a80d4ca1">cx_real_t</a> &gt; &amp;input, arma::Mat&lt; <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> &gt; &amp;output, <a class="el" href="namespacestp.html#a464d541245c3d8f9ea82f5d2d5484c98">FFTRoutine</a> r_fft=<a class="el" href="namespacestp.html#a464d541245c3d8f9ea82f5d2d5484c98a1551a8f00e3ff5f46b18636fb963ad8c">FFTRoutine::FFTW_ESTIMATE_FFT</a>, const std::string &amp;wisdom_filename=std::string())</td></tr>
<tr class="memdesc:a4af482cb10c30fd252b434dd0aef3074"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the backward fast fourier transform on a halfplane complex matrix using the FFTW library (complex to real FFT)  <a href="#a4af482cb10c30fd252b434dd0aef3074">More...</a><br /></td></tr>
<tr class="separator:a4af482cb10c30fd252b434dd0aef3074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e2f269ecab0adf2e78e20b32f6a5a53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestp.html#a6e2f269ecab0adf2e78e20b32f6a5a53">fft_fftw_r2c</a> (arma::Mat&lt; <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> &gt; &amp;input, arma::Mat&lt; <a class="el" href="types_8h.html#a1d2a57e59f061705d305d324a80d4ca1">cx_real_t</a> &gt; &amp;output, <a class="el" href="namespacestp.html#a464d541245c3d8f9ea82f5d2d5484c98">FFTRoutine</a> r_fft=<a class="el" href="namespacestp.html#a464d541245c3d8f9ea82f5d2d5484c98a1551a8f00e3ff5f46b18636fb963ad8c">FFTRoutine::FFTW_ESTIMATE_FFT</a>, const std::string &amp;wisdom_filename=std::string())</td></tr>
<tr class="memdesc:a6e2f269ecab0adf2e78e20b32f6a5a53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the forward fast fourier transform on a real matrix using the FFTW library (real to complex FFT)  <a href="#a6e2f269ecab0adf2e78e20b32f6a5a53">More...</a><br /></td></tr>
<tr class="separator:a6e2f269ecab0adf2e78e20b32f6a5a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4e9a876d5c753d6dd3bda54f6d85119"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestp.html#ac4e9a876d5c753d6dd3bda54f6d85119">generate_hermitian_matrix_from_nonredundant</a> (arma::Mat&lt; <a class="el" href="types_8h.html#a1d2a57e59f061705d305d324a80d4ca1">cx_real_t</a> &gt; &amp;matrix)</td></tr>
<tr class="memdesc:ac4e9a876d5c753d6dd3bda54f6d85119"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a hermitian matrix from the non-redundant values.  <a href="#ac4e9a876d5c753d6dd3bda54f6d85119">More...</a><br /></td></tr>
<tr class="separator:ac4e9a876d5c753d6dd3bda54f6d85119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8147549e9e6af9bc222ab8bd39c4407d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8147549e9e6af9bc222ab8bd39c4407d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestp.html#a8147549e9e6af9bc222ab8bd39c4407d">fftshift</a> (arma::Mat&lt; T &gt; &amp;m, bool is_forward=true)</td></tr>
<tr class="memdesc:a8147549e9e6af9bc222ab8bd39c4407d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs matrix circular shift as needed for iFFT.  <a href="#a8147549e9e6af9bc222ab8bd39c4407d">More...</a><br /></td></tr>
<tr class="separator:a8147549e9e6af9bc222ab8bd39c4407d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a289ceab89f470979ff8f3a16af91b382"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestp.html#a289ceab89f470979ff8f3a16af91b382">mat_median_exact</a> (const arma::Mat&lt; <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> &gt; &amp;data)</td></tr>
<tr class="memdesc:a289ceab89f470979ff8f3a16af91b382"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute exact median using the nth_element function.  <a href="#a289ceab89f470979ff8f3a16af91b382">More...</a><br /></td></tr>
<tr class="separator:a289ceab89f470979ff8f3a16af91b382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4a233c007f57992374feef8d621a50f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structstp_1_1_data_stats.html">DataStats</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestp.html#ae4a233c007f57992374feef8d621a50f">mat_binmedian</a> (const arma::Mat&lt; <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> &gt; &amp;data)</td></tr>
<tr class="memdesc:ae4a233c007f57992374feef8d621a50f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute exact median using a method that combines sucessive binning and nth_element function.  <a href="#ae4a233c007f57992374feef8d621a50f">More...</a><br /></td></tr>
<tr class="separator:ae4a233c007f57992374feef8d621a50f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a6eb0890f98de3f27e5342cd288672e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structstp_1_1_data_stats.html">DataStats</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestp.html#a8a6eb0890f98de3f27e5342cd288672e">mat_median_binapprox</a> (const arma::Mat&lt; <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> &gt; &amp;data)</td></tr>
<tr class="memdesc:a8a6eb0890f98de3f27e5342cd288672e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute approximation of the median using the binapprox method.  <a href="#a8a6eb0890f98de3f27e5342cd288672e">More...</a><br /></td></tr>
<tr class="separator:a8a6eb0890f98de3f27e5342cd288672e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaec4a7dcd30598f388f96794a9c44c68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structstp_1_1_data_stats.html">DataStats</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestp.html#aaec4a7dcd30598f388f96794a9c44c68">mat_mean_and_stddev</a> (const arma::Mat&lt; <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> &gt; &amp;data)</td></tr>
<tr class="memdesc:aaec4a7dcd30598f388f96794a9c44c68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute matrix mean and standard deviation at once.  <a href="#aaec4a7dcd30598f388f96794a9c44c68">More...</a><br /></td></tr>
<tr class="separator:aaec4a7dcd30598f388f96794a9c44c68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5186254c1cfa0304a9e924ec6cbda038"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestp.html#a5186254c1cfa0304a9e924ec6cbda038">mat_accumulate</a> (arma::Mat&lt; <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> &gt; &amp;data)</td></tr>
<tr class="memdesc:a5186254c1cfa0304a9e924ec6cbda038"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accumulate matrix elements (single thread implementation).  <a href="#a5186254c1cfa0304a9e924ec6cbda038">More...</a><br /></td></tr>
<tr class="separator:a5186254c1cfa0304a9e924ec6cbda038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04a59a5383b4ff8ffa4e7d988d3cd588"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestp.html#a04a59a5383b4ff8ffa4e7d988d3cd588">mat_accumulate_parallel</a> (arma::Mat&lt; <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> &gt; &amp;data)</td></tr>
<tr class="memdesc:a04a59a5383b4ff8ffa4e7d988d3cd588"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accumulate matrix elements (parallel implementation).  <a href="#a04a59a5383b4ff8ffa4e7d988d3cd588">More...</a><br /></td></tr>
<tr class="separator:a04a59a5383b4ff8ffa4e7d988d3cd588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f430dc49c6d6dc55c46cec479659419"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestp.html#a0f430dc49c6d6dc55c46cec479659419">mat_mean</a> (arma::Mat&lt; <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> &gt; &amp;data)</td></tr>
<tr class="memdesc:a0f430dc49c6d6dc55c46cec479659419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute matrix mean (single thread implementation).  <a href="#a0f430dc49c6d6dc55c46cec479659419">More...</a><br /></td></tr>
<tr class="separator:a0f430dc49c6d6dc55c46cec479659419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fb8607c7d28f9d5378ec98cfe8c2e85"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestp.html#a6fb8607c7d28f9d5378ec98cfe8c2e85">mat_mean_parallel</a> (arma::Mat&lt; <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> &gt; &amp;data)</td></tr>
<tr class="memdesc:a6fb8607c7d28f9d5378ec98cfe8c2e85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute matrix mean (parallel).  <a href="#a6fb8607c7d28f9d5378ec98cfe8c2e85">More...</a><br /></td></tr>
<tr class="separator:a6fb8607c7d28f9d5378ec98cfe8c2e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a482026f966a8261e7146bc429a03c2e0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestp.html#a482026f966a8261e7146bc429a03c2e0">mat_stddev_parallel</a> (arma::Mat&lt; <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> &gt; &amp;data, double mean=arma::datum::nan)</td></tr>
<tr class="memdesc:a482026f966a8261e7146bc429a03c2e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute matrix standard deviation (parallel).  <a href="#a482026f966a8261e7146bc429a03c2e0">More...</a><br /></td></tr>
<tr class="separator:a482026f966a8261e7146bc429a03c2e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad37648a3b9f67014a4e20050b9d7b478"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad37648a3b9f67014a4e20050b9d7b478"><td class="memTemplItemLeft" align="right" valign="top">arma::Mat&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestp.html#ad37648a3b9f67014a4e20050b9d7b478">matrix_shift</a> (const arma::Mat&lt; T &gt; &amp;in, const int length, const int dim=0)</td></tr>
<tr class="memdesc:ad37648a3b9f67014a4e20050b9d7b478"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift elements of the input matrix in a circular manner.  <a href="#ad37648a3b9f67014a4e20050b9d7b478">More...</a><br /></td></tr>
<tr class="separator:ad37648a3b9f67014a4e20050b9d7b478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dec62be138cc7a88f2fb0eebae6c63e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1dec62be138cc7a88f2fb0eebae6c63e"><td class="memTemplItemLeft" align="right" valign="top">arma::mat&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestp.html#a1dec62be138cc7a88f2fb0eebae6c63e">make_kernel_array</a> (const T &amp;kernel_creator, int support, const arma::mat &amp;offset, int oversampling=1, bool pad=false, bool normalize=true)</td></tr>
<tr class="memdesc:a1dec62be138cc7a88f2fb0eebae6c63e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make 2D Kernel Array.  <a href="#a1dec62be138cc7a88f2fb0eebae6c63e">More...</a><br /></td></tr>
<tr class="separator:a1dec62be138cc7a88f2fb0eebae6c63e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae328999b307d32ea32e65caa64eac0b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aae328999b307d32ea32e65caa64eac0b"><td class="memTemplItemLeft" align="right" valign="top">arma::vec&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestp.html#aae328999b307d32ea32e65caa64eac0b">make_1D_kernel</a> (const T &amp;kernel_creator, int support, const double offset, int oversampling=1, bool pad=false, bool normalize=true)</td></tr>
<tr class="memdesc:aae328999b307d32ea32e65caa64eac0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make 1D Kernel Array.  <a href="#aae328999b307d32ea32e65caa64eac0b">More...</a><br /></td></tr>
<tr class="separator:aae328999b307d32ea32e65caa64eac0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64e9b2a4405d8f3ded5155a4c9cdf844"><td class="memItemLeft" align="right" valign="top">arma::uvec&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestp.html#a64e9b2a4405d8f3ded5155a4c9cdf844">bounds_check_kernel_centre_locations</a> (arma::imat &amp;kernel_centre_indices, int support, int image_size)</td></tr>
<tr class="memdesc:a64e9b2a4405d8f3ded5155a4c9cdf844"><td class="mdescLeft">&#160;</td><td class="mdescRight">bounds_check_kernel_centre_locations function  <a href="#a64e9b2a4405d8f3ded5155a4c9cdf844">More...</a><br /></td></tr>
<tr class="separator:a64e9b2a4405d8f3ded5155a4c9cdf844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2191add2b4abbc6ff7cb8c4102097ca"><td class="memItemLeft" align="right" valign="top">arma::imat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestp.html#ad2191add2b4abbc6ff7cb8c4102097ca">calculate_oversampled_kernel_indices</a> (arma::mat &amp;subpixel_coord, int oversampling)</td></tr>
<tr class="memdesc:ad2191add2b4abbc6ff7cb8c4102097ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate_oversampled_kernel_indices function  <a href="#ad2191add2b4abbc6ff7cb8c4102097ca">More...</a><br /></td></tr>
<tr class="separator:ad2191add2b4abbc6ff7cb8c4102097ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d34b3ed2504bd5c0fc106e3299a5d62"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9d34b3ed2504bd5c0fc106e3299a5d62"><td class="memTemplItemLeft" align="right" valign="top">arma::field&lt; arma::mat &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestp.html#a9d34b3ed2504bd5c0fc106e3299a5d62">populate_kernel_cache</a> (const T &amp;kernel_creator, const int support, const int oversampling, const bool pad=false, const bool normalize=true)</td></tr>
<tr class="memdesc:a9d34b3ed2504bd5c0fc106e3299a5d62"><td class="mdescLeft">&#160;</td><td class="mdescRight">populate_kernel_cache function  <a href="#a9d34b3ed2504bd5c0fc106e3299a5d62">More...</a><br /></td></tr>
<tr class="separator:a9d34b3ed2504bd5c0fc106e3299a5d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a847bd8453dae496b2f22556831568c9a"><td class="memTemplParams" colspan="2">template&lt;bool generateBeam, typename T &gt; </td></tr>
<tr class="memitem:a847bd8453dae496b2f22556831568c9a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstp_1_1_gridder_output.html">GridderOutput</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestp.html#a847bd8453dae496b2f22556831568c9a">convolve_to_grid</a> (const T &amp;kernel_creator, const int support, int image_size, const arma::mat &amp;uv, const arma::cx_mat &amp;vis, const arma::mat &amp;vis_weights, bool kernel_exact=true, int oversampling=1, bool pad=false, bool normalize=true, bool shift_uv=true, bool halfplane_gridding=true)</td></tr>
<tr class="memdesc:a847bd8453dae496b2f22556831568c9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Grid visibilities using convolutional gridding.  <a href="#a847bd8453dae496b2f22556831568c9a">More...</a><br /></td></tr>
<tr class="separator:a847bd8453dae496b2f22556831568c9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a095277dc88e800af18a5e1e9e803792e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestp.html#a095277dc88e800af18a5e1e9e803792e">convert_to_halfplane_visibilities</a> (arma::mat &amp;uv_in_pixels, arma::cx_mat &amp;vis, arma::mat &amp;vis_weights, int kernel_support)</td></tr>
<tr class="memdesc:a095277dc88e800af18a5e1e9e803792e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the input visibilities to an array of half-plane visibilities.  <a href="#a095277dc88e800af18a5e1e9e803792e">More...</a><br /></td></tr>
<tr class="separator:a095277dc88e800af18a5e1e9e803792e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e61918609243705d9649a09c4efd1ba"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7e61918609243705d9649a09c4efd1ba"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; arma::Mat&lt; <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> &gt;, arma::Mat&lt; <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestp.html#a7e61918609243705d9649a09c4efd1ba">image_visibilities</a> (const T kernel_creator, const arma::cx_mat &amp;vis, const arma::mat &amp;vis_weights, const arma::mat &amp;uvw_lambda, int image_size, double cell_size, int kernel_support, bool kernel_exact=true, int oversampling=1, bool generate_beam=false, <a class="el" href="namespacestp.html#a464d541245c3d8f9ea82f5d2d5484c98">FFTRoutine</a> r_fft=<a class="el" href="namespacestp.html#a464d541245c3d8f9ea82f5d2d5484c98a1551a8f00e3ff5f46b18636fb963ad8c">FFTRoutine::FFTW_ESTIMATE_FFT</a>, const std::string &amp;fft_wisdom_filename=std::string())</td></tr>
<tr class="memdesc:a7e61918609243705d9649a09c4efd1ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates image and beam data from input visibilities.  <a href="#a7e61918609243705d9649a09c4efd1ba">More...</a><br /></td></tr>
<tr class="separator:a7e61918609243705d9649a09c4efd1ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a276a9a7f4bb8bc1db6451515349d3e8d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestp.html#a276a9a7f4bb8bc1db6451515349d3e8d">estimate_rms</a> (const arma::Mat&lt; <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> &gt; &amp;data, double num_sigma=3, uint iters=5, <a class="el" href="structstp_1_1_data_stats.html">DataStats</a> stats=<a class="el" href="structstp_1_1_data_stats.html">DataStats</a>(arma::datum::nan, arma::datum::nan, arma::datum::nan))</td></tr>
<tr class="memdesc:a276a9a7f4bb8bc1db6451515349d3e8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform sigma-clip and estimate RMS of input matrix.  <a href="#a276a9a7f4bb8bc1db6451515349d3e8d">More...</a><br /></td></tr>
<tr class="separator:a276a9a7f4bb8bc1db6451515349d3e8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4376d9dfa3b7a21f1ca69629c347d99"><td class="memItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestp.html#ab4376d9dfa3b7a21f1ca69629c347d99">degree_to_rad</a> (double value)</td></tr>
<tr class="memdesc:ab4376d9dfa3b7a21f1ca69629c347d99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert value in degrees to radians.  <a href="#ab4376d9dfa3b7a21f1ca69629c347d99">More...</a><br /></td></tr>
<tr class="separator:ab4376d9dfa3b7a21f1ca69629c347d99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ff833f501186b663177e7761a61405e"><td class="memItemLeft" align="right" valign="top">arma::cx_mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestp.html#a4ff833f501186b663177e7761a61405e">visibilities_for_point_source</a> (arma::mat &amp;dist_uvw, double l, double m, double flux)</td></tr>
<tr class="memdesc:a4ff833f501186b663177e7761a61405e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simulate visibilities for point source.  <a href="#a4ff833f501186b663177e7761a61405e">More...</a><br /></td></tr>
<tr class="separator:a4ff833f501186b663177e7761a61405e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbc82270e03dee57c2a67c3a81f0369c"><td class="memItemLeft" align="right" valign="top">arma::cx_mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestp.html#afbc82270e03dee57c2a67c3a81f0369c">generate_visibilities_from_local_skymodel</a> (arma::mat &amp;skymodel, arma::mat &amp;uvw_baselines)</td></tr>
<tr class="memdesc:afbc82270e03dee57c2a67c3a81f0369c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a set of model visibilities given a skymodel and UVW-baselines.  <a href="#afbc82270e03dee57c2a67c3a81f0369c">More...</a><br /></td></tr>
<tr class="separator:afbc82270e03dee57c2a67c3a81f0369c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a54c6b61e9265ab85495b35c81b13d43d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::chrono::high_resolution_clock::time_point &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestp.html#a54c6b61e9265ab85495b35c81b13d43d">times_sf</a></td></tr>
<tr class="separator:a54c6b61e9265ab85495b35c81b13d43d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a640f9d473d4790d262ed74f21ecc3335"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestp.html#a640f9d473d4790d262ed74f21ecc3335">fptolerance</a> = 1.0e-10</td></tr>
<tr class="separator:a640f9d473d4790d262ed74f21ecc3335"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a30ea75fc2a28e18b48e3a9939e3760a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30ea75fc2a28e18b48e3a9939e3760a9">&#9670;&nbsp;</a></span>CeresDiffMethod</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacestp.html#a30ea75fc2a28e18b48e3a9939e3760a9">stp::CeresDiffMethod</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enum of available differentiation methods used by ceres library for gaussian fitting. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a30ea75fc2a28e18b48e3a9939e3760a9ae8967ede587723717837909c3712390e"></a>AutoDiff&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a30ea75fc2a28e18b48e3a9939e3760a9a4db6200d2a3fb2b994ff83a49c99a6d4"></a>AutoDiff_SingleResBlk&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a30ea75fc2a28e18b48e3a9939e3760a9accc88f7642b52779190d6a143d1a8fe7"></a>AnalyticDiff&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a30ea75fc2a28e18b48e3a9939e3760a9a22112738903c086da2e47ba0dc8f8d9e"></a>AnalyticDiff_SingleResBlk&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ae604b01190a3a3414720a85c806fd7d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae604b01190a3a3414720a85c806fd7d6">&#9670;&nbsp;</a></span>CeresSolverType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacestp.html#ae604b01190a3a3414720a85c806fd7d6">stp::CeresSolverType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enum of available solver types used by ceres library for gaussian fitting. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ae604b01190a3a3414720a85c806fd7d6afd0d5b1f6ee7757ec90dce1107dcef00"></a>LinearSearch_BFGS&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae604b01190a3a3414720a85c806fd7d6a25f51874b6aac8fb933c164f9d42778c"></a>LinearSearch_LBFGS&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae604b01190a3a3414720a85c806fd7d6a4d89de3a5b02f9f6f445cbe2358a8675"></a>TrustRegion_DenseQR&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a464d541245c3d8f9ea82f5d2d5484c98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a464d541245c3d8f9ea82f5d2d5484c98">&#9670;&nbsp;</a></span>FFTRoutine</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacestp.html#a464d541245c3d8f9ea82f5d2d5484c98">stp::FFTRoutine</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enum of available FFT algorithms. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a464d541245c3d8f9ea82f5d2d5484c98a1551a8f00e3ff5f46b18636fb963ad8c"></a>FFTW_ESTIMATE_FFT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a464d541245c3d8f9ea82f5d2d5484c98a5b1699ed6ddd9a9360937797edfe3873"></a>FFTW_MEASURE_FFT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a464d541245c3d8f9ea82f5d2d5484c98af7b85ceb556fa3fccee760843b070ceb"></a>FFTW_PATIENT_FFT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a464d541245c3d8f9ea82f5d2d5484c98ab6cc625b02ae42496e8baea63abf1243"></a>FFTW_WISDOM_FFT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a464d541245c3d8f9ea82f5d2d5484c98ac68eed57a11ce9105b7e0355d5b2e84d"></a>FFTW_WISDOM_INPLACE_FFT&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a92421a2e1781ba7c1263b57c12082d58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92421a2e1781ba7c1263b57c12082d58">&#9670;&nbsp;</a></span>KernelFunction</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacestp.html#a92421a2e1781ba7c1263b57c12082d58">stp::KernelFunction</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enum of available kernel functions. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a92421a2e1781ba7c1263b57c12082d58acd678285c2431c505ac62192462e0b04"></a>TopHat&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a92421a2e1781ba7c1263b57c12082d58a5e5500cb2b82eb72d550de644bd1b64b"></a>Triangle&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a92421a2e1781ba7c1263b57c12082d58a43e79bd61fa47e2cbc202a93f921c406"></a>Sinc&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a92421a2e1781ba7c1263b57c12082d58afedf7ba6075fb5526a7ace0b9385528d"></a>Gaussian&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a92421a2e1781ba7c1263b57c12082d58a74fa5da616c7dcd36f467abc96241471"></a>GaussianSinc&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a64e9b2a4405d8f3ded5155a4c9cdf844"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64e9b2a4405d8f3ded5155a4c9cdf844">&#9670;&nbsp;</a></span>bounds_check_kernel_centre_locations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arma::uvec stp::bounds_check_kernel_centre_locations </td>
          <td>(</td>
          <td class="paramtype">arma::imat &amp;&#160;</td>
          <td class="paramname"><em>kernel_centre_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>support</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>image_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>bounds_check_kernel_centre_locations function </p>
<p>Vectorized bounds check.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">kernel_centre_indices(arma::imat)</td><td>Corresponding array of nearest-pixel grid-locations, which will be the centre position of a kernel placement. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">support</td><td>(int): Kernel support size in regular pixels. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">image_size</td><td>(int): Image width in pixels</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(uvec): List of indices for 'good' (in-bounds) positions. Note this is a list of integer index values. </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestp_a64e9b2a4405d8f3ded5155a4c9cdf844_icgraph.png" border="0" usemap="#namespacestp_a64e9b2a4405d8f3ded5155a4c9cdf844_icgraph" alt=""/></div>
<map name="namespacestp_a64e9b2a4405d8f3ded5155a4c9cdf844_icgraph" id="namespacestp_a64e9b2a4405d8f3ded5155a4c9cdf844_icgraph">
<area shape="rect" id="node2" href="namespacestp.html#a9d34b3ed2504bd5c0fc106e3299a5d62" title="populate_kernel_cache function " alt="" coords="228,5,367,47"/>
<area shape="rect" id="node3" href="namespacestp.html#a847bd8453dae496b2f22556831568c9a" title="Grid visibilities using convolutional gridding. " alt="" coords="415,42,561,69"/>
</map>
</div>

</div>
</div>
<a id="ad2191add2b4abbc6ff7cb8c4102097ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2191add2b4abbc6ff7cb8c4102097ca">&#9670;&nbsp;</a></span>calculate_oversampled_kernel_indices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arma::imat stp::calculate_oversampled_kernel_indices </td>
          <td>(</td>
          <td class="paramtype">arma::mat &amp;&#160;</td>
          <td class="paramname"><em>subpixel_coord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>oversampling</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculate_oversampled_kernel_indices function </p>
<p>Find the nearest oversampled gridpoint for given sub-pixel offset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">subpixel_coord</td><td>(arma::mat): Array of 'fractional' co-ords, that is the subpixel offsets from nearest pixel on the regular grid. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">oversampling</td><td>(int). How many oversampled pixels to one regular pixel.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(arma::imat): Corresponding oversampled pixel indexes </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestp_ad2191add2b4abbc6ff7cb8c4102097ca_icgraph.png" border="0" usemap="#namespacestp_ad2191add2b4abbc6ff7cb8c4102097ca_icgraph" alt=""/></div>
<map name="namespacestp_ad2191add2b4abbc6ff7cb8c4102097ca_icgraph" id="namespacestp_ad2191add2b4abbc6ff7cb8c4102097ca_icgraph">
<area shape="rect" id="node2" href="namespacestp.html#a9d34b3ed2504bd5c0fc106e3299a5d62" title="populate_kernel_cache function " alt="" coords="235,5,373,47"/>
<area shape="rect" id="node3" href="namespacestp.html#a847bd8453dae496b2f22556831568c9a" title="Grid visibilities using convolutional gridding. " alt="" coords="421,42,568,69"/>
</map>
</div>

</div>
</div>
<a id="a095277dc88e800af18a5e1e9e803792e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a095277dc88e800af18a5e1e9e803792e">&#9670;&nbsp;</a></span>convert_to_halfplane_visibilities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stp::convert_to_halfplane_visibilities </td>
          <td>(</td>
          <td class="paramtype">arma::mat &amp;&#160;</td>
          <td class="paramname"><em>uv_in_pixels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::cx_mat &amp;&#160;</td>
          <td class="paramname"><em>vis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::mat &amp;&#160;</td>
          <td class="paramname"><em>vis_weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>kernel_support</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the input visibilities to an array of half-plane visibilities. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uvw_lambda</td><td>(arma::mat): UVW-coordinates of complex visibilities to be converted. 2D double array with 3 columns. Assumed ordering is u,v,w. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vis</td><td>(arma::cx_mat): Complex visibilities to be converted (1D array). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vis_weights</td><td>(arma::mat): Visibility weights (1D array). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kernel_support</td><td>(int): Kernel support radius. </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestp_a095277dc88e800af18a5e1e9e803792e_icgraph.png" border="0" usemap="#namespacestp_a095277dc88e800af18a5e1e9e803792e_icgraph" alt=""/></div>
<map name="namespacestp_a095277dc88e800af18a5e1e9e803792e_icgraph" id="namespacestp_a095277dc88e800af18a5e1e9e803792e_icgraph">
<area shape="rect" id="node2" href="namespacestp.html#a7e61918609243705d9649a09c4efd1ba" title="Generates image and beam data from input visibilities. " alt="" coords="221,13,368,39"/>
</map>
</div>

</div>
</div>
<a id="a847bd8453dae496b2f22556831568c9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a847bd8453dae496b2f22556831568c9a">&#9670;&nbsp;</a></span>convolve_to_grid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool generateBeam, typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstp_1_1_gridder_output.html">GridderOutput</a> stp::convolve_to_grid </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>kernel_creator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>support</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>image_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arma::mat &amp;&#160;</td>
          <td class="paramname"><em>uv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arma::cx_mat &amp;&#160;</td>
          <td class="paramname"><em>vis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arma::mat &amp;&#160;</td>
          <td class="paramname"><em>vis_weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>kernel_exact</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>oversampling</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pad</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>normalize</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shift_uv</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>halfplane_gridding</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Grid visibilities using convolutional gridding. </p>
<p>Returns the <b>un-normalized</b> weighted visibilities; the weights-renormalization factor can be calculated by summing the sample grid.</p>
<p>If 'exact == True' then exact gridding is used, i.e. the kernel is recalculated for each visibility, with precise sub-pixel offset according to that visibility's UV co-ordinates. Otherwise, instead of recalculating the kernel for each sub-pixel location, we pre-generate an oversampled kernel ahead of time - so e.g. for an oversampling of 5, the kernel is pre-generated at 0.2 pixel-width offsets. We then pick the pre-generated kernel corresponding to the sub-pixel offset nearest to that of the visibility. Kernel pre-generation results in improved performance, particularly with large numbers of visibilities and complex kernel functions, at the cost of introducing minor aliasing effects due to the 'step-like' nature of the oversampled kernel. This in turn can be minimised (at the cost of longer start-up times and larger memory usage) by pre-generating kernels with a larger oversampling ratio, to give finer interpolation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">T&amp;</td><td>kernel_creator : the kernel creator functor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">support</td><td>(int) : Defines the 'radius' of the bounding box within which convolution takes place. <code>Box width in pixels = 2*support+1</code>. (The central pixel is the one nearest to the UV co-ordinates.) (This is sometimes known as the 'half-support') </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">image_size</td><td>(int) : Width of the image in pixels. NB we assume the pixel <code>[image_size//2,image_size//2]</code> corresponds to the origin in UV-space. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uv</td><td>(arma::mat) : UV-coordinates of visibilities. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vis</td><td>(arma::cx_mat) : Complex visibilities. 1d array, shape: (n_vis). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vis_weights</td><td>(arma::mat) : Visibility weights. 1d array, shape: (n_vis). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kernel_exact</td><td>(bool) : Calculate exact kernel-values for every UV-sample. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">oversampling</td><td>(int) : Controls kernel-generation if <code>exact==False</code>. Larger values give a finer-sampled set of pre-cached kernels. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pad</td><td>(bool) : Whether to pad the array by an extra pixel-width. This is used when generating an oversampled kernel that will be used for interpolation. Default is false. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">normalize</td><td>(bool) : Whether to normalize generated kernel functions. Default is true. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">shift_uv</td><td>(bool) : Shift uv-coordinates before gridding (required when fftshift function is skipped before fft). Default is true. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">halfplane_gridding</td><td>(bool) : Grid only halfplane matrix. Used when halfplane c2r fft is used. Default is true.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(GridderRes) 2 slices: vis_grid and sampling_grid, representing the gridded visibilities and the sampling weights. One value with the total sampling grid sum. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestp_a847bd8453dae496b2f22556831568c9a_cgraph.png" border="0" usemap="#namespacestp_a847bd8453dae496b2f22556831568c9a_cgraph" alt=""/></div>
<map name="namespacestp_a847bd8453dae496b2f22556831568c9a_cgraph" id="namespacestp_a847bd8453dae496b2f22556831568c9a_cgraph">
<area shape="rect" id="node2" href="namespacestp.html#a64e9b2a4405d8f3ded5155a4c9cdf844" title="bounds_check_kernel_centre_locations function " alt="" coords="410,5,585,47"/>
<area shape="rect" id="node3" href="namespacestp.html#a9d34b3ed2504bd5c0fc106e3299a5d62" title="populate_kernel_cache function " alt="" coords="210,64,349,105"/>
<area shape="rect" id="node5" href="namespacestp.html#ad2191add2b4abbc6ff7cb8c4102097ca" title="calculate_oversampled_kernel_indices function " alt="" coords="407,123,588,164"/>
<area shape="rect" id="node6" href="namespacestp.html#a1dec62be138cc7a88f2fb0eebae6c63e" title="Make 2D Kernel Array. " alt="" coords="200,181,359,207"/>
<area shape="rect" id="node7" href="classstp_1_1_gridder_output.html#a875fc3decf005dff279ed0d43195942b" title="stp::GridderOutput\l::GridderOutput" alt="" coords="215,232,344,273"/>
<area shape="rect" id="node4" href="namespacestp.html#aae328999b307d32ea32e65caa64eac0b" title="Make 1D Kernel Array. " alt="" coords="424,71,571,98"/>
</map>
</div>

</div>
</div>
<a id="ab4376d9dfa3b7a21f1ca69629c347d99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4376d9dfa3b7a21f1ca69629c347d99">&#9670;&nbsp;</a></span>degree_to_rad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr double stp::degree_to_rad </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert value in degrees to radians. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>(double): value in degrees</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(double): value in radians </dd></dl>

</div>
</div>
<a id="a276a9a7f4bb8bc1db6451515349d3e8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a276a9a7f4bb8bc1db6451515349d3e8d">&#9670;&nbsp;</a></span>estimate_rms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double stp::estimate_rms </td>
          <td>(</td>
          <td class="paramtype">const arma::Mat&lt; <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>num_sigma</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>iters</em> = <code>5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstp_1_1_data_stats.html">DataStats</a>&#160;</td>
          <td class="paramname"><em>stats</em> = <code><a class="el" href="structstp_1_1_data_stats.html">DataStats</a>(arma::datum::nan,&#160;arma::datum::nan,&#160;arma::datum::nan)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform sigma-clip and estimate RMS of input matrix. </p>
<p>Compute Root mean square of input data after sigma-clipping (combines RMS estimation and sigma clip functions for improved computational performance). Sigma clip is based on the pyhton's sigma_clip function in astropy.stats.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>(arma::Mat): Input data matrix. Data is not changed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sigma</td><td>(double): The number of standard deviations to use for both the lower and upper clipping limit. Defaults to 3. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iters</td><td>(uint): The number of iterations for sigma clipping. Defaults to 5. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stats</td><td>(<a class="el" href="structstp_1_1_data_stats.html" title="Struct that stores computed statistics: mean, sigma, median. ">DataStats</a>): The mean, sigma and median values to be used. If non-finite values are passed, they must be computed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(double): Computed Root Mean Square value. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestp_a276a9a7f4bb8bc1db6451515349d3e8d_cgraph.png" border="0" usemap="#namespacestp_a276a9a7f4bb8bc1db6451515349d3e8d_cgraph" alt=""/></div>
<map name="namespacestp_a276a9a7f4bb8bc1db6451515349d3e8d_cgraph" id="namespacestp_a276a9a7f4bb8bc1db6451515349d3e8d_cgraph">
<area shape="rect" id="node2" href="namespacestp.html#a8a6eb0890f98de3f27e5342cd288672e" title="Compute approximation of the median using the binapprox method. " alt="" coords="180,31,363,57"/>
<area shape="rect" id="node3" href="namespacestp.html#aaec4a7dcd30598f388f96794a9c44c68" title="Compute matrix mean and standard deviation at once. " alt="" coords="411,5,593,32"/>
<area shape="rect" id="node4" href="namespacestp.html#a289ceab89f470979ff8f3a16af91b382" title="Compute exact median using the nth_element function. " alt="" coords="423,56,581,83"/>
</map>
</div>

</div>
</div>
<a id="a4af482cb10c30fd252b434dd0aef3074"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4af482cb10c30fd252b434dd0aef3074">&#9670;&nbsp;</a></span>fft_fftw_c2r()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stp::fft_fftw_c2r </td>
          <td>(</td>
          <td class="paramtype">arma::Mat&lt; <a class="el" href="types_8h.html#a1d2a57e59f061705d305d324a80d4ca1">cx_real_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::Mat&lt; <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacestp.html#a464d541245c3d8f9ea82f5d2d5484c98">FFTRoutine</a>&#160;</td>
          <td class="paramname"><em>r_fft</em> = <code><a class="el" href="namespacestp.html#a464d541245c3d8f9ea82f5d2d5484c98a1551a8f00e3ff5f46b18636fb963ad8c">FFTRoutine::FFTW_ESTIMATE_FFT</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>wisdom_filename</em> = <code>std::string()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the backward fast fourier transform on a halfplane complex matrix using the FFTW library (complex to real FFT) </p>
<p>Receives the halfplane complex matrix (n_rows = n_cols/2 +1) and performs the backward fast fourier transform returning a real output matrix. Find more details about c2r (complex to real) FFT in the FFTW manual.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>(arma::Mat) : Complex input matrix to be transformed using fft </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">output</td><td>(arma::Mat) : Real output matrix with the fft result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r_fft</td><td>(FFTRoutine enum) : FFT routine to be used: defines the FFTW planner flag </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wisdom_filename</td><td>(string) : FFTW wisdom filename (optional) </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestp_a4af482cb10c30fd252b434dd0aef3074_icgraph.png" border="0" usemap="#namespacestp_a4af482cb10c30fd252b434dd0aef3074_icgraph" alt=""/></div>
<map name="namespacestp_a4af482cb10c30fd252b434dd0aef3074_icgraph" id="namespacestp_a4af482cb10c30fd252b434dd0aef3074_icgraph">
<area shape="rect" id="node2" href="namespacestp.html#a7e61918609243705d9649a09c4efd1ba" title="Generates image and beam data from input visibilities. " alt="" coords="168,5,315,32"/>
</map>
</div>

</div>
</div>
<a id="a6e2f269ecab0adf2e78e20b32f6a5a53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e2f269ecab0adf2e78e20b32f6a5a53">&#9670;&nbsp;</a></span>fft_fftw_r2c()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stp::fft_fftw_r2c </td>
          <td>(</td>
          <td class="paramtype">arma::Mat&lt; <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::Mat&lt; <a class="el" href="types_8h.html#a1d2a57e59f061705d305d324a80d4ca1">cx_real_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacestp.html#a464d541245c3d8f9ea82f5d2d5484c98">FFTRoutine</a>&#160;</td>
          <td class="paramname"><em>r_fft</em> = <code><a class="el" href="namespacestp.html#a464d541245c3d8f9ea82f5d2d5484c98a1551a8f00e3ff5f46b18636fb963ad8c">FFTRoutine::FFTW_ESTIMATE_FFT</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>wisdom_filename</em> = <code>std::string()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the forward fast fourier transform on a real matrix using the FFTW library (real to complex FFT) </p>
<p>Receives the real matrix (n_rows = n_cols) and performs the forward fast fourier transform returning a complex output matrix. Find more details about r2c (real to complex) FFT in the FFTW manual.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>(arma::Mat) : Real input matrix to be transformed using fft </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">output</td><td>(arma::Mat) : Complex halfplane output matrix with the fft result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r_fft</td><td>(FFTRoutine enum) : FFT routine to be used: defines the FFTW planner flag </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wisdom_filename</td><td>(string) : FFTW wisdom filename (optional) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8147549e9e6af9bc222ab8bd39c4407d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8147549e9e6af9bc222ab8bd39c4407d">&#9670;&nbsp;</a></span>fftshift()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stp::fftshift </td>
          <td>(</td>
          <td class="paramtype">arma::Mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_forward</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs matrix circular shift as needed for iFFT. </p>
<p>Shift the zero-frequency component to the centre of the spectrum.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>(arma::Mat&lt;T&gt;) : The matrix to be shifted (shifted matrix is also stored here) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_forward</td><td>(bool) Shifts forward if true (default), backward otherwise </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestp_a8147549e9e6af9bc222ab8bd39c4407d_cgraph.png" border="0" usemap="#namespacestp_a8147549e9e6af9bc222ab8bd39c4407d_cgraph" alt=""/></div>
<map name="namespacestp_a8147549e9e6af9bc222ab8bd39c4407d_cgraph" id="namespacestp_a8147549e9e6af9bc222ab8bd39c4407d_cgraph">
<area shape="rect" id="node2" href="namespacestp.html#ad37648a3b9f67014a4e20050b9d7b478" title="Shift elements of the input matrix in a circular manner. " alt="" coords="139,5,255,32"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestp_a8147549e9e6af9bc222ab8bd39c4407d_icgraph.png" border="0" usemap="#namespacestp_a8147549e9e6af9bc222ab8bd39c4407d_icgraph" alt=""/></div>
<map name="namespacestp_a8147549e9e6af9bc222ab8bd39c4407d_icgraph" id="namespacestp_a8147549e9e6af9bc222ab8bd39c4407d_icgraph">
<area shape="rect" id="node2" href="namespacestp.html#a7e61918609243705d9649a09c4efd1ba" title="Generates image and beam data from input visibilities. " alt="" coords="139,5,285,32"/>
</map>
</div>

</div>
</div>
<a id="ac4e9a876d5c753d6dd3bda54f6d85119"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4e9a876d5c753d6dd3bda54f6d85119">&#9670;&nbsp;</a></span>generate_hermitian_matrix_from_nonredundant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stp::generate_hermitian_matrix_from_nonredundant </td>
          <td>(</td>
          <td class="paramtype">arma::Mat&lt; <a class="el" href="types_8h.html#a1d2a57e59f061705d305d324a80d4ca1">cx_real_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a hermitian matrix from the non-redundant values. </p>
<p>Receives a complex matrix with the non-redundant values (as returned by the fft_r2c FFTW function) which is used to generate the full hermitian matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>(arma::Mat) : Complex matrix with the non-redundant values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afbc82270e03dee57c2a67c3a81f0369c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbc82270e03dee57c2a67c3a81f0369c">&#9670;&nbsp;</a></span>generate_visibilities_from_local_skymodel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arma::cx_mat stp::generate_visibilities_from_local_skymodel </td>
          <td>(</td>
          <td class="paramtype">arma::mat &amp;&#160;</td>
          <td class="paramname"><em>skymodel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::mat &amp;&#160;</td>
          <td class="paramname"><em>uvw_baselines</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a set of model visibilities given a skymodel and UVW-baselines. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">skymodel</td><td>(arma::mat): The local skymodel. Array of triples [l,m,flux_jy], where 'l,m' are the directional cosines for this source, and 'flux_jy' is flux in Janskys. Shape: (n_baselines, 3) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uvw_baselines</td><td>(arma::mat): UVW baselines (units of lambda). Shape: (n_baselines, 3)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>arma::cx_mat: Complex visibilities sum for each baseline. Length: n_baselines. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestp_afbc82270e03dee57c2a67c3a81f0369c_cgraph.png" border="0" usemap="#namespacestp_afbc82270e03dee57c2a67c3a81f0369c_cgraph" alt=""/></div>
<map name="namespacestp_afbc82270e03dee57c2a67c3a81f0369c_cgraph" id="namespacestp_afbc82270e03dee57c2a67c3a81f0369c_cgraph">
<area shape="rect" id="node2" href="namespacestp.html#a4ff833f501186b663177e7761a61405e" title="Simulate visibilities for point source. " alt="" coords="216,5,343,47"/>
</map>
</div>

</div>
</div>
<a id="a7e61918609243705d9649a09c4efd1ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e61918609243705d9649a09c4efd1ba">&#9670;&nbsp;</a></span>image_visibilities()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;arma::Mat&lt;<a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a>&gt;, arma::Mat&lt;<a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a>&gt; &gt; stp::image_visibilities </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>kernel_creator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arma::cx_mat &amp;&#160;</td>
          <td class="paramname"><em>vis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arma::mat &amp;&#160;</td>
          <td class="paramname"><em>vis_weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arma::mat &amp;&#160;</td>
          <td class="paramname"><em>uvw_lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>image_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cell_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>kernel_support</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>kernel_exact</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>oversampling</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>generate_beam</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacestp.html#a464d541245c3d8f9ea82f5d2d5484c98">FFTRoutine</a>&#160;</td>
          <td class="paramname"><em>r_fft</em> = <code><a class="el" href="namespacestp.html#a464d541245c3d8f9ea82f5d2d5484c98a1551a8f00e3ff5f46b18636fb963ad8c">FFTRoutine::FFTW_ESTIMATE_FFT</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fft_wisdom_filename</em> = <code>std::string()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates image and beam data from input visibilities. </p>
<p>Performs convolutional gridding of input visibilities and applies ifft. Returns two arrays representing the image map and beam model.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">kernel_creator</td><td>(typename T): Callable object that returns a convolution kernel. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vis</td><td>(arma::cx_mat): Complex visibilities (1D array). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vis_weights</td><td>(arma::mat): Visibility weights (1D array). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uvw_lambda</td><td>(arma::mat): UVW-coordinates of complex visibilities. Units are multiples of wavelength. 2D double array with 3 columns. Assumed ordering is u,v,w. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">image_size</td><td>(int): Width of the image in pixels. Assumes (image_size/2, image_size/2) corresponds to the origin in UV-space. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cell_size</td><td>(double): Angular-width of a synthesized pixel in the image to be created (arcsecond). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kernel_support</td><td>(int): Defines the 'radius' of the bounding box within which convolution takes place (also known as half-support). Box width in pixels = 2*support + 1. The central pixel is the one nearest to the UV co-ordinates. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kernel_exact</td><td>(bool): Calculate exact kernel-values for every UV-sample. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">oversampling</td><td>(int): Controls kernel-generation if 'kernel_exact == False'. Larger values give a finer-sampled set of pre-cached kernels. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">generate_beam</td><td>(bool): Enables generation of gridded sampling matrix. Default is false. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r_fft</td><td>(FFTRoutine): Selects FFT routine to be used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fft_wisdom_filename</td><td>(string): FFTW wisdom filename for the image and beam (c2r fft).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(std::pair&lt;arma::mat, arma::mat&gt;): Two matrices representing the generated image map and beam model (image, beam). </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestp_a7e61918609243705d9649a09c4efd1ba_cgraph.png" border="0" usemap="#namespacestp_a7e61918609243705d9649a09c4efd1ba_cgraph" alt=""/></div>
<map name="namespacestp_a7e61918609243705d9649a09c4efd1ba_cgraph" id="namespacestp_a7e61918609243705d9649a09c4efd1ba_cgraph">
<area shape="rect" id="node2" href="namespacestp.html#a095277dc88e800af18a5e1e9e803792e" title="Convert the input visibilities to an array of half&#45;plane visibilities. " alt="" coords="200,5,368,47"/>
<area shape="rect" id="node3" href="namespacestp.html#a4af482cb10c30fd252b434dd0aef3074" title="Performs the backward fast fourier transform on a halfplane complex matrix using the FFTW library (co..." alt="" coords="227,71,341,98"/>
<area shape="rect" id="node4" href="classstp_1_1_mat_stp.html#a647f2e90b61e3e2a43c9f3baa8b3c248" title="Delete matrix buffer. " alt="" coords="217,123,351,164"/>
<area shape="rect" id="node5" href="namespacestp.html#a8147549e9e6af9bc222ab8bd39c4407d" title="Performs matrix circular shift as needed for iFFT. " alt="" coords="241,189,327,215"/>
<area shape="rect" id="node6" href="namespacestp.html#ad37648a3b9f67014a4e20050b9d7b478" title="Shift elements of the input matrix in a circular manner. " alt="" coords="416,189,532,215"/>
</map>
</div>

</div>
</div>
<a id="af25487cd82119504b148bd619af82062"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af25487cd82119504b148bd619af82062">&#9670;&nbsp;</a></span>labeling()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool findNegative&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;<a class="el" href="classstp_1_1_mat_stp.html">MatStp</a>&lt;int&gt;, <a class="el" href="classstp_1_1_mat_stp.html">MatStp</a>&lt;uint&gt;, uint, uint&gt; stp::labeling </td>
          <td>(</td>
          <td class="paramtype">const arma::Mat&lt; <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a>&#160;</td>
          <td class="paramname"><em>analysis_thresh_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a>&#160;</td>
          <td class="paramname"><em>analysis_thresh_neg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the connected components labeling (CCL) algorithm using 4-connectivity. </p>
<p>Algorithm is based on "Two Strategies to Speed up Connected Components Algorithms", the SAUF (Scan array union find) variant using decision trees. Kesheng Wu, et al Note: rows are encoded as position in the "rows" array to save lookup times</p>
<p>Uses a parallel implementation which divides the input image in horizontal slices (power of 2 size). This function does not perform the final labeling stage. The label map is thus returned using temporary labels. This design decision allows to merge the final labeling stage with the search of max/min sources, performed after this step. For this reason, the array of decision tree is returned to be used in the final labeling stage.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">I</td><td>(arma::Mat) : Input data matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">analysis_thresh_pos</td><td>(real_t) : Analysis threshold for detection of positive sources </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">analysis_thresh_neg</td><td>(real_t) : Analysis threshold for detection of negative sources</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(std::tuple) Tuple object containing the label map matrix (arma::Mat), the array of decision tree (arma::Mat), the mumber of positive labels (uint) and the number of negative labels (uint) </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestp_af25487cd82119504b148bd619af82062_cgraph.png" border="0" usemap="#namespacestp_af25487cd82119504b148bd619af82062_cgraph" alt=""/></div>
<map name="namespacestp_af25487cd82119504b148bd619af82062_cgraph" id="namespacestp_af25487cd82119504b148bd619af82062_cgraph">
<area shape="rect" id="node2" href="structstp_1_1_label_data_thread.html#afd42a0cb27b1c61f7957a3335eb9d3eb" title="LabelDataThread default constructor. " alt="" coords="145,5,292,47"/>
</map>
</div>

</div>
</div>
<a id="aae328999b307d32ea32e65caa64eac0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae328999b307d32ea32e65caa64eac0b">&#9670;&nbsp;</a></span>make_1D_kernel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma::vec stp::make_1D_kernel </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>kernel_creator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>support</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>oversampling</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pad</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>normalize</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make 1D Kernel Array. </p>
<p>Function (template + functor) to create 1D Kernel array with some specs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">kernel_creator</td><td>functor used for kernel generation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">support</td><td>(int): Defines the 'radius' of the bounding box within which convolution takes place. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>(double): subpixel offset from the sampling position of the central pixel to the origin of the kernel function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">oversampling</td><td>(int): Controls kernel-generation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pad</td><td>(bool): Whether to pad the array by an extra pixel-width. This is used when generating an oversampled kernel that will be used for interpolation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">normalize</td><td>(bool): Whether or not the returned image should be normalized</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(arma::vec) Result 1D kernel </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestp_aae328999b307d32ea32e65caa64eac0b_icgraph.png" border="0" usemap="#namespacestp_aae328999b307d32ea32e65caa64eac0b_icgraph" alt=""/></div>
<map name="namespacestp_aae328999b307d32ea32e65caa64eac0b_icgraph" id="namespacestp_aae328999b307d32ea32e65caa64eac0b_icgraph">
<area shape="rect" id="node2" href="namespacestp.html#a9d34b3ed2504bd5c0fc106e3299a5d62" title="populate_kernel_cache function " alt="" coords="200,5,339,47"/>
<area shape="rect" id="node3" href="namespacestp.html#a847bd8453dae496b2f22556831568c9a" title="Grid visibilities using convolutional gridding. " alt="" coords="387,13,533,39"/>
</map>
</div>

</div>
</div>
<a id="a1dec62be138cc7a88f2fb0eebae6c63e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dec62be138cc7a88f2fb0eebae6c63e">&#9670;&nbsp;</a></span>make_kernel_array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma::mat stp::make_kernel_array </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>kernel_creator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>support</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arma::mat &amp;&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>oversampling</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pad</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>normalize</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make 2D Kernel Array. </p>
<p>Function (template + functor) to create a Kernel array with some specs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">kernel_creator</td><td>functor used for kernel generation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">support</td><td>(int): Defines the 'radius' of the bounding box within which convolution takes place. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>(arma::vec): 2-vector subpixel offset from the sampling position of the central pixel to the origin of the kernel function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">oversampling</td><td>(int): Controls kernel-generation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pad</td><td>(bool): Whether to pad the array by an extra pixel-width. This is used when generating an oversampled kernel that will be used for interpolation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">normalize</td><td>(bool): Whether or not the returned image should be normalized</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result kernel </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestp_a1dec62be138cc7a88f2fb0eebae6c63e_icgraph.png" border="0" usemap="#namespacestp_a1dec62be138cc7a88f2fb0eebae6c63e_icgraph" alt=""/></div>
<map name="namespacestp_a1dec62be138cc7a88f2fb0eebae6c63e_icgraph" id="namespacestp_a1dec62be138cc7a88f2fb0eebae6c63e_icgraph">
<area shape="rect" id="node2" href="namespacestp.html#a847bd8453dae496b2f22556831568c9a" title="Grid visibilities using convolutional gridding. " alt="" coords="212,5,359,32"/>
</map>
</div>

</div>
</div>
<a id="a5186254c1cfa0304a9e924ec6cbda038"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5186254c1cfa0304a9e924ec6cbda038">&#9670;&nbsp;</a></span>mat_accumulate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double stp::mat_accumulate </td>
          <td>(</td>
          <td class="paramtype">arma::Mat&lt; <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accumulate matrix elements (single thread implementation). </p>
<p>Provides single threaded implementation of matrix elements' accumulation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>(arma::Mat): Input matrix with elements to be accumulated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(double): Accumulation value. </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestp_a5186254c1cfa0304a9e924ec6cbda038_icgraph.png" border="0" usemap="#namespacestp_a5186254c1cfa0304a9e924ec6cbda038_icgraph" alt=""/></div>
<map name="namespacestp_a5186254c1cfa0304a9e924ec6cbda038_icgraph" id="namespacestp_a5186254c1cfa0304a9e924ec6cbda038_icgraph">
<area shape="rect" id="node2" href="namespacestp.html#a0f430dc49c6d6dc55c46cec479659419" title="Compute matrix mean (single thread implementation). " alt="" coords="197,5,307,32"/>
<area shape="rect" id="node3" href="structstp_1_1_double_pair.html#a33a214de9ae3e8a4e78e70f81ffa2a6e" title="DoublePair constructor that sets two double numbers. " alt="" coords="355,31,539,57"/>
</map>
</div>

</div>
</div>
<a id="a04a59a5383b4ff8ffa4e7d988d3cd588"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04a59a5383b4ff8ffa4e7d988d3cd588">&#9670;&nbsp;</a></span>mat_accumulate_parallel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double stp::mat_accumulate_parallel </td>
          <td>(</td>
          <td class="paramtype">arma::Mat&lt; <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accumulate matrix elements (parallel implementation). </p>
<p>Provides parallel implementation of matrix elements' accumulation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>(arma::Mat): Input matrix with elements to be accumulated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(double): Accumulation value. </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestp_a04a59a5383b4ff8ffa4e7d988d3cd588_icgraph.png" border="0" usemap="#namespacestp_a04a59a5383b4ff8ffa4e7d988d3cd588_icgraph" alt=""/></div>
<map name="namespacestp_a04a59a5383b4ff8ffa4e7d988d3cd588_icgraph" id="namespacestp_a04a59a5383b4ff8ffa4e7d988d3cd588_icgraph">
<area shape="rect" id="node2" href="namespacestp.html#a6fb8607c7d28f9d5378ec98cfe8c2e85" title="Compute matrix mean (parallel). " alt="" coords="197,56,355,83"/>
<area shape="rect" id="node4" href="structstp_1_1_double_pair.html#a33a214de9ae3e8a4e78e70f81ffa2a6e" title="DoublePair constructor that sets two double numbers. " alt="" coords="615,56,799,83"/>
<area shape="rect" id="node3" href="namespacestp.html#a482026f966a8261e7146bc429a03c2e0" title="Compute matrix standard deviation (parallel). " alt="" coords="403,5,567,32"/>
</map>
</div>

</div>
</div>
<a id="ae4a233c007f57992374feef8d621a50f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4a233c007f57992374feef8d621a50f">&#9670;&nbsp;</a></span>mat_binmedian()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstp_1_1_data_stats.html">DataStats</a> stp::mat_binmedian </td>
          <td>(</td>
          <td class="paramtype">const arma::Mat&lt; <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute exact median using a method that combines sucessive binning and nth_element function. </p>
<p>Provides parallel implementation of modified binmedian - a fast method to find exact median. The method is based on binmedian algorithm (by Ryan Tibshirani) available at: <a href="http://www.stat.cmu.edu/~ryantibs/median/">http://www.stat.cmu.edu/~ryantibs/median/</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>(arma::Mat): Input matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(<a class="el" href="structstp_1_1_data_stats.html" title="Struct that stores computed statistics: mean, sigma, median. ">DataStats</a>): Exact median, mean and sigma. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestp_ae4a233c007f57992374feef8d621a50f_cgraph.png" border="0" usemap="#namespacestp_ae4a233c007f57992374feef8d621a50f_cgraph" alt=""/></div>
<map name="namespacestp_ae4a233c007f57992374feef8d621a50f_cgraph" id="namespacestp_ae4a233c007f57992374feef8d621a50f_cgraph">
<area shape="rect" id="node2" href="namespacestp.html#aaec4a7dcd30598f388f96794a9c44c68" title="Compute matrix mean and standard deviation at once. " alt="" coords="189,5,372,32"/>
<area shape="rect" id="node3" href="namespacestp.html#a289ceab89f470979ff8f3a16af91b382" title="Compute exact median using the nth_element function. " alt="" coords="201,56,360,83"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestp_ae4a233c007f57992374feef8d621a50f_icgraph.png" border="0" usemap="#namespacestp_ae4a233c007f57992374feef8d621a50f_icgraph" alt=""/></div>
<map name="namespacestp_ae4a233c007f57992374feef8d621a50f_icgraph" id="namespacestp_ae4a233c007f57992374feef8d621a50f_icgraph">
<area shape="rect" id="node2" href="structstp_1_1_double_pair.html#a33a214de9ae3e8a4e78e70f81ffa2a6e" title="DoublePair constructor that sets two double numbers. " alt="" coords="189,5,373,32"/>
</map>
</div>

</div>
</div>
<a id="a0f430dc49c6d6dc55c46cec479659419"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f430dc49c6d6dc55c46cec479659419">&#9670;&nbsp;</a></span>mat_mean()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double stp::mat_mean </td>
          <td>(</td>
          <td class="paramtype">arma::Mat&lt; <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute matrix mean (single thread implementation). </p>
<p>Provides single threaded implementation of matrix mean.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>(arma::Mat): Input matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(double): Mean value of input matrix. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestp_a0f430dc49c6d6dc55c46cec479659419_cgraph.png" border="0" usemap="#namespacestp_a0f430dc49c6d6dc55c46cec479659419_cgraph" alt=""/></div>
<map name="namespacestp_a0f430dc49c6d6dc55c46cec479659419_cgraph" id="namespacestp_a0f430dc49c6d6dc55c46cec479659419_cgraph">
<area shape="rect" id="node2" href="namespacestp.html#a5186254c1cfa0304a9e924ec6cbda038" title="Accumulate matrix elements (single thread implementation). " alt="" coords="163,5,307,32"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestp_a0f430dc49c6d6dc55c46cec479659419_icgraph.png" border="0" usemap="#namespacestp_a0f430dc49c6d6dc55c46cec479659419_icgraph" alt=""/></div>
<map name="namespacestp_a0f430dc49c6d6dc55c46cec479659419_icgraph" id="namespacestp_a0f430dc49c6d6dc55c46cec479659419_icgraph">
<area shape="rect" id="node2" href="structstp_1_1_double_pair.html#a33a214de9ae3e8a4e78e70f81ffa2a6e" title="DoublePair constructor that sets two double numbers. " alt="" coords="163,5,347,32"/>
</map>
</div>

</div>
</div>
<a id="aaec4a7dcd30598f388f96794a9c44c68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaec4a7dcd30598f388f96794a9c44c68">&#9670;&nbsp;</a></span>mat_mean_and_stddev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstp_1_1_data_stats.html">DataStats</a> stp::mat_mean_and_stddev </td>
          <td>(</td>
          <td class="paramtype">const arma::Mat&lt; <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute matrix mean and standard deviation at once. </p>
<p>Provides parallel implementation of matrix mean and standard deviation. This function uses a single loop over data to compute both quantities at once and thus get better performance. It does not use a numerically stable implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>(arma::Mat): Input matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(<a class="el" href="structstp_1_1_data_stats.html" title="Struct that stores computed statistics: mean, sigma, median. ">DataStats</a>): Mean and standard deviation values. </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestp_aaec4a7dcd30598f388f96794a9c44c68_icgraph.png" border="0" usemap="#namespacestp_aaec4a7dcd30598f388f96794a9c44c68_icgraph" alt=""/></div>
<map name="namespacestp_aaec4a7dcd30598f388f96794a9c44c68_icgraph" id="namespacestp_aaec4a7dcd30598f388f96794a9c44c68_icgraph">
<area shape="rect" id="node2" href="namespacestp.html#ae4a233c007f57992374feef8d621a50f" title="Compute exact median using a method that combines sucessive binning and nth_element function..." alt="" coords="259,5,395,32"/>
<area shape="rect" id="node3" href="structstp_1_1_double_pair.html#a33a214de9ae3e8a4e78e70f81ffa2a6e" title="DoublePair constructor that sets two double numbers. " alt="" coords="467,56,651,83"/>
<area shape="rect" id="node4" href="namespacestp.html#a8a6eb0890f98de3f27e5342cd288672e" title="Compute approximation of the median using the binapprox method. " alt="" coords="236,107,419,133"/>
<area shape="rect" id="node5" href="namespacestp.html#a276a9a7f4bb8bc1db6451515349d3e8d" title="Perform sigma&#45;clip and estimate RMS of input matrix. " alt="" coords="495,107,622,133"/>
</map>
</div>

</div>
</div>
<a id="a6fb8607c7d28f9d5378ec98cfe8c2e85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fb8607c7d28f9d5378ec98cfe8c2e85">&#9670;&nbsp;</a></span>mat_mean_parallel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double stp::mat_mean_parallel </td>
          <td>(</td>
          <td class="paramtype">arma::Mat&lt; <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute matrix mean (parallel). </p>
<p>Provides parallel implementation of matrix mean.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>(arma::Mat): Input matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(double): Mean value of input matrix. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestp_a6fb8607c7d28f9d5378ec98cfe8c2e85_cgraph.png" border="0" usemap="#namespacestp_a6fb8607c7d28f9d5378ec98cfe8c2e85_cgraph" alt=""/></div>
<map name="namespacestp_a6fb8607c7d28f9d5378ec98cfe8c2e85_cgraph" id="namespacestp_a6fb8607c7d28f9d5378ec98cfe8c2e85_cgraph">
<area shape="rect" id="node2" href="namespacestp.html#a04a59a5383b4ff8ffa4e7d988d3cd588" title="Accumulate matrix elements (parallel implementation). " alt="" coords="211,5,355,47"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestp_a6fb8607c7d28f9d5378ec98cfe8c2e85_icgraph.png" border="0" usemap="#namespacestp_a6fb8607c7d28f9d5378ec98cfe8c2e85_icgraph" alt=""/></div>
<map name="namespacestp_a6fb8607c7d28f9d5378ec98cfe8c2e85_icgraph" id="namespacestp_a6fb8607c7d28f9d5378ec98cfe8c2e85_icgraph">
<area shape="rect" id="node2" href="namespacestp.html#a482026f966a8261e7146bc429a03c2e0" title="Compute matrix standard deviation (parallel). " alt="" coords="211,5,375,32"/>
<area shape="rect" id="node3" href="structstp_1_1_double_pair.html#a33a214de9ae3e8a4e78e70f81ffa2a6e" title="DoublePair constructor that sets two double numbers. " alt="" coords="423,31,607,57"/>
</map>
</div>

</div>
</div>
<a id="a8a6eb0890f98de3f27e5342cd288672e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a6eb0890f98de3f27e5342cd288672e">&#9670;&nbsp;</a></span>mat_median_binapprox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstp_1_1_data_stats.html">DataStats</a> stp::mat_median_binapprox </td>
          <td>(</td>
          <td class="paramtype">const arma::Mat&lt; <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute approximation of the median using the binapprox method. </p>
<p>Provides parallel implementation of the binapprox method to compute an approximation of the median. The median error is guaranteed to be inferior to sigma/1000. An algorithm description and its paper (by Ryan Tibshirani) are available at: <a href="http://www.stat.cmu.edu/~ryantibs/median/">http://www.stat.cmu.edu/~ryantibs/median/</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>(arma::Mat): Input matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(<a class="el" href="structstp_1_1_data_stats.html" title="Struct that stores computed statistics: mean, sigma, median. ">DataStats</a>): Approximation of the median value. Also returns mean and sigma. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestp_a8a6eb0890f98de3f27e5342cd288672e_cgraph.png" border="0" usemap="#namespacestp_a8a6eb0890f98de3f27e5342cd288672e_cgraph" alt=""/></div>
<map name="namespacestp_a8a6eb0890f98de3f27e5342cd288672e_cgraph" id="namespacestp_a8a6eb0890f98de3f27e5342cd288672e_cgraph">
<area shape="rect" id="node2" href="namespacestp.html#aaec4a7dcd30598f388f96794a9c44c68" title="Compute matrix mean and standard deviation at once. " alt="" coords="236,5,419,32"/>
<area shape="rect" id="node3" href="namespacestp.html#a289ceab89f470979ff8f3a16af91b382" title="Compute exact median using the nth_element function. " alt="" coords="248,56,407,83"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestp_a8a6eb0890f98de3f27e5342cd288672e_icgraph.png" border="0" usemap="#namespacestp_a8a6eb0890f98de3f27e5342cd288672e_icgraph" alt=""/></div>
<map name="namespacestp_a8a6eb0890f98de3f27e5342cd288672e_icgraph" id="namespacestp_a8a6eb0890f98de3f27e5342cd288672e_icgraph">
<area shape="rect" id="node2" href="structstp_1_1_double_pair.html#a33a214de9ae3e8a4e78e70f81ffa2a6e" title="DoublePair constructor that sets two double numbers. " alt="" coords="236,5,420,32"/>
<area shape="rect" id="node3" href="namespacestp.html#a276a9a7f4bb8bc1db6451515349d3e8d" title="Perform sigma&#45;clip and estimate RMS of input matrix. " alt="" coords="265,56,391,83"/>
</map>
</div>

</div>
</div>
<a id="a289ceab89f470979ff8f3a16af91b382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a289ceab89f470979ff8f3a16af91b382">&#9670;&nbsp;</a></span>mat_median_exact()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double stp::mat_median_exact </td>
          <td>(</td>
          <td class="paramtype">const arma::Mat&lt; <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute exact median using the nth_element function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>(arma::Mat): Input matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(double): Exact median. </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestp_a289ceab89f470979ff8f3a16af91b382_icgraph.png" border="0" usemap="#namespacestp_a289ceab89f470979ff8f3a16af91b382_icgraph" alt=""/></div>
<map name="namespacestp_a289ceab89f470979ff8f3a16af91b382_icgraph" id="namespacestp_a289ceab89f470979ff8f3a16af91b382_icgraph">
<area shape="rect" id="node2" href="namespacestp.html#ae4a233c007f57992374feef8d621a50f" title="Compute exact median using a method that combines sucessive binning and nth_element function..." alt="" coords="235,5,371,32"/>
<area shape="rect" id="node3" href="structstp_1_1_double_pair.html#a33a214de9ae3e8a4e78e70f81ffa2a6e" title="DoublePair constructor that sets two double numbers. " alt="" coords="443,56,627,83"/>
<area shape="rect" id="node4" href="namespacestp.html#a8a6eb0890f98de3f27e5342cd288672e" title="Compute approximation of the median using the binapprox method. " alt="" coords="212,107,395,133"/>
<area shape="rect" id="node5" href="namespacestp.html#a276a9a7f4bb8bc1db6451515349d3e8d" title="Perform sigma&#45;clip and estimate RMS of input matrix. " alt="" coords="471,107,598,133"/>
</map>
</div>

</div>
</div>
<a id="a482026f966a8261e7146bc429a03c2e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a482026f966a8261e7146bc429a03c2e0">&#9670;&nbsp;</a></span>mat_stddev_parallel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double stp::mat_stddev_parallel </td>
          <td>(</td>
          <td class="paramtype">arma::Mat&lt; <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mean</em> = <code>arma::datum::nan</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute matrix standard deviation (parallel). </p>
<p>Provides parallel implementation of matrix standard deviation. If a pre-computed mean value is received, mean calculation is bypassed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>(arma::Mat): Input matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">double</td><td>(mean): Pre-computed mean value (optional).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(double): Standard deviation of input matrix. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestp_a482026f966a8261e7146bc429a03c2e0_cgraph.png" border="0" usemap="#namespacestp_a482026f966a8261e7146bc429a03c2e0_cgraph" alt=""/></div>
<map name="namespacestp_a482026f966a8261e7146bc429a03c2e0_cgraph" id="namespacestp_a482026f966a8261e7146bc429a03c2e0_cgraph">
<area shape="rect" id="node2" href="namespacestp.html#a6fb8607c7d28f9d5378ec98cfe8c2e85" title="Compute matrix mean (parallel). " alt="" coords="217,13,375,39"/>
<area shape="rect" id="node3" href="namespacestp.html#a04a59a5383b4ff8ffa4e7d988d3cd588" title="Accumulate matrix elements (parallel implementation). " alt="" coords="423,5,567,47"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestp_a482026f966a8261e7146bc429a03c2e0_icgraph.png" border="0" usemap="#namespacestp_a482026f966a8261e7146bc429a03c2e0_icgraph" alt=""/></div>
<map name="namespacestp_a482026f966a8261e7146bc429a03c2e0_icgraph" id="namespacestp_a482026f966a8261e7146bc429a03c2e0_icgraph">
<area shape="rect" id="node2" href="structstp_1_1_double_pair.html#a33a214de9ae3e8a4e78e70f81ffa2a6e" title="DoublePair constructor that sets two double numbers. " alt="" coords="217,5,401,32"/>
</map>
</div>

</div>
</div>
<a id="ad37648a3b9f67014a4e20050b9d7b478"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad37648a3b9f67014a4e20050b9d7b478">&#9670;&nbsp;</a></span>matrix_shift()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma::Mat&lt;T&gt; stp::matrix_shift </td>
          <td>(</td>
          <td class="paramtype">const arma::Mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shift elements of the input matrix in a circular manner. </p>
<p>Provides matrix shift operation based on armadillo implementation, but it uses TBB for parallel processing. Template function allows to shift diferent matrix types, e.g. arma::mat, arma::cx_mat</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>(arma::Mat&lt;T&gt;): Matrix to be shifted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lenght</td><td>(int): Number of positions to shifted (can be positive or negative). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim(int)</td><td>If dim=0, shift each column by "lenght". If dim=1, shift each row by "lenght". Default is 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(arma::Mat&lt;T&gt; ): Shifted version of input matrix. </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestp_ad37648a3b9f67014a4e20050b9d7b478_icgraph.png" border="0" usemap="#namespacestp_ad37648a3b9f67014a4e20050b9d7b478_icgraph" alt=""/></div>
<map name="namespacestp_ad37648a3b9f67014a4e20050b9d7b478_icgraph" id="namespacestp_ad37648a3b9f67014a4e20050b9d7b478_icgraph">
<area shape="rect" id="node2" href="namespacestp.html#a8147549e9e6af9bc222ab8bd39c4407d" title="Performs matrix circular shift as needed for iFFT. " alt="" coords="169,5,255,32"/>
<area shape="rect" id="node3" href="namespacestp.html#a7e61918609243705d9649a09c4efd1ba" title="Generates image and beam data from input visibilities. " alt="" coords="303,5,449,32"/>
</map>
</div>

</div>
</div>
<a id="a9d34b3ed2504bd5c0fc106e3299a5d62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d34b3ed2504bd5c0fc106e3299a5d62">&#9670;&nbsp;</a></span>populate_kernel_cache()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma::field&lt;arma::mat&gt; stp::populate_kernel_cache </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>kernel_creator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>support</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>oversampling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>pad</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>normalize</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>populate_kernel_cache function </p>
<p>Generate a cache of normalised kernels at oversampled-pixel offsets.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">T&amp;</td><td>kernel_creator : the kernel creator functor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">support</td><td>(int): See kernel generation routine. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">oversampling</td><td>(int): Oversampling ratio value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pad</td><td>(bool) : Whether to pad the array by an extra pixel-width. This is used when generating an oversampled kernel that will be used for interpolation. Default is false. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">normalize</td><td>(bool). Whether to normalize generated kernel functions. Default is true.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(arma::field&lt;arma::mat&gt;): Mapping oversampling-pixel offsets to normalised kernels. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestp_a9d34b3ed2504bd5c0fc106e3299a5d62_cgraph.png" border="0" usemap="#namespacestp_a9d34b3ed2504bd5c0fc106e3299a5d62_cgraph" alt=""/></div>
<map name="namespacestp_a9d34b3ed2504bd5c0fc106e3299a5d62_cgraph" id="namespacestp_a9d34b3ed2504bd5c0fc106e3299a5d62_cgraph">
<area shape="rect" id="node2" href="namespacestp.html#aae328999b307d32ea32e65caa64eac0b" title="Make 1D Kernel Array. " alt="" coords="209,5,356,32"/>
<area shape="rect" id="node3" href="namespacestp.html#a64e9b2a4405d8f3ded5155a4c9cdf844" title="bounds_check_kernel_centre_locations function " alt="" coords="195,57,370,98"/>
<area shape="rect" id="node4" href="namespacestp.html#ad2191add2b4abbc6ff7cb8c4102097ca" title="calculate_oversampled_kernel_indices function " alt="" coords="192,122,373,163"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestp_a9d34b3ed2504bd5c0fc106e3299a5d62_icgraph.png" border="0" usemap="#namespacestp_a9d34b3ed2504bd5c0fc106e3299a5d62_icgraph" alt=""/></div>
<map name="namespacestp_a9d34b3ed2504bd5c0fc106e3299a5d62_icgraph" id="namespacestp_a9d34b3ed2504bd5c0fc106e3299a5d62_icgraph">
<area shape="rect" id="node2" href="namespacestp.html#a847bd8453dae496b2f22556831568c9a" title="Grid visibilities using convolutional gridding. " alt="" coords="192,13,339,39"/>
</map>
</div>

</div>
</div>
<a id="a4ff833f501186b663177e7761a61405e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ff833f501186b663177e7761a61405e">&#9670;&nbsp;</a></span>visibilities_for_point_source()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arma::cx_mat stp::visibilities_for_point_source </td>
          <td>(</td>
          <td class="paramtype">arma::mat &amp;&#160;</td>
          <td class="paramname"><em>dist_uvw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>flux</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simulate visibilities for point source. </p>
<p>Calculate visibilities for a source located at angular position (l,m) relative to observed phase centre as used for calculating baselines in UVW space. Note that point source is delta function, therefore FT relationship becomes an exponential, evaluated at (uvw.lmn)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dist_uvw</td><td>(arma::mat): Array of 3-vectors representing baselines in UVW space [lambda]. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">l</td><td>(double): Direction cosines in RA direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>(double): Direction cosines in Dec direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flux</td><td>(double): Flux [Jy]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>arma::cx_mat: Array of complex visibilities </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestp_a4ff833f501186b663177e7761a61405e_icgraph.png" border="0" usemap="#namespacestp_a4ff833f501186b663177e7761a61405e_icgraph" alt=""/></div>
<map name="namespacestp_a4ff833f501186b663177e7761a61405e_icgraph" id="namespacestp_a4ff833f501186b663177e7761a61405e_icgraph">
<area shape="rect" id="node2" href="namespacestp.html#afbc82270e03dee57c2a67c3a81f0369c" title="Generate a set of model visibilities given a skymodel and UVW&#45;baselines. " alt="" coords="180,5,343,47"/>
</map>
</div>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a640f9d473d4790d262ed74f21ecc3335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a640f9d473d4790d262ed74f21ecc3335">&#9670;&nbsp;</a></span>fptolerance</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> stp::fptolerance = 1.0e-10</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a54c6b61e9265ab85495b35c81b13d43d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54c6b61e9265ab85495b35c81b13d43d">&#9670;&nbsp;</a></span>times_sf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::chrono::high_resolution_clock::time_point&gt; stp::times_sf</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
