<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Slow Transients Pipeline Prototype: stp Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="science_data_processor_logo.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Slow Transients Pipeline Prototype
   </div>
   <div id="projectbrief">Component of the Science Data Processor being developed in the context of the Square Kilometre Array international project, which provides fast snapshot imaging, object detection and cataloguing for the identification of astrophysical image-plane transients.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">stp Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstp_1_1_a___projection_pars.html">A_ProjectionPars</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A-projection settings.  <a href="structstp_1_1_a___projection_pars.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstp_1_1_bounding_box.html">BoundingBox</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents bounding box positions: top, bottom, left and right margins.  <a href="structstp_1_1_bounding_box.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstp_1_1_data_stats.html">DataStats</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct that stores computed statistics: mean, sigma, median.  <a href="structstp_1_1_data_stats.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstp_1_1_double_pair.html">DoublePair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct that stores a pair of doubles.  <a href="structstp_1_1_double_pair.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionstp_1_1_float_twiddler.html">FloatTwiddler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a floation-point number that can be accessed using the integer type. This union allows to perform bitwise operations using the integer type interface.  <a href="unionstp_1_1_float_twiddler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstp_1_1_gaussian.html">Gaussian</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classstp_1_1_gaussian.html" title="The Gaussian functor class. ">Gaussian</a> functor class.  <a href="classstp_1_1_gaussian.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstp_1_1_gaussian2d_params.html">Gaussian2dParams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structstp_1_1_gaussian2d_params.html" title="The Gaussian2dParams struct. ">Gaussian2dParams</a> struct.  <a href="structstp_1_1_gaussian2d_params.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstp_1_1_gaussian_all_residuals.html">GaussianAllResiduals</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor that computes all residuals between source data and 2D gaussian model.  <a href="classstp_1_1_gaussian_all_residuals.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstp_1_1_gaussian_analytic.html">GaussianAnalytic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes residual and jacobian on the given point x,y for gaussian fitting using analytic derivatives.  <a href="classstp_1_1_gaussian_analytic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstp_1_1_gaussian_analytic_all_residuals.html">GaussianAnalyticAllResiduals</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes all source residuals and jacobians for gaussian fitting using analytic derivatives.  <a href="classstp_1_1_gaussian_analytic_all_residuals.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstp_1_1_gaussian_residual.html">GaussianResidual</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor that computes the residual on the given point x,y between source data and 2D gaussian model.  <a href="classstp_1_1_gaussian_residual.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstp_1_1_gaussian_sinc.html">GaussianSinc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classstp_1_1_gaussian_sinc.html" title="The GaussianSinc functor class. ">GaussianSinc</a> functor class.  <a href="classstp_1_1_gaussian_sinc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstp_1_1_gridder_output.html">GridderOutput</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The gridder output class.  <a href="classstp_1_1_gridder_output.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstp_1_1_imager_pars.html">ImagerPars</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Imager settings.  <a href="structstp_1_1_imager_pars.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstp_1_1_image_visibilities.html">ImageVisibilities</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classstp_1_1_image_visibilities.html" title="ImageVisibilities class. Runs imager. ">ImageVisibilities</a> class. Runs imager.  <a href="classstp_1_1_image_visibilities.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstp_1_1_island_params.html">IslandParams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structstp_1_1_island_params.html" title="IslandParams struct. ">IslandParams</a> struct.  <a href="structstp_1_1_island_params.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstp_1_1_label_data_thread.html">LabelDataThread</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structstp_1_1_label_data_thread.html" title="LabelDataThread struct is used to store start column and detected label information of a thread...">LabelDataThread</a> struct is used to store start column and detected label information of a thread.  <a href="structstp_1_1_label_data_thread.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstp_1_1_mat_stp.html">MatStp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classstp_1_1_mat_stp.html" title="The MatStp matrix class. ">MatStp</a> matrix class.  <a href="classstp_1_1_mat_stp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstp_1_1_p_s_w_f.html">PSWF</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Prolate spheroidal wave function (<a class="el" href="classstp_1_1_p_s_w_f.html" title="The Prolate spheroidal wave function (PSWF) functor class. ">PSWF</a>) functor class.  <a href="classstp_1_1_p_s_w_f.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstp_1_1_sinc.html">Sinc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classstp_1_1_sinc.html" title="The Sinc functor class. ">Sinc</a> functor class.  <a href="classstp_1_1_sinc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstp_1_1_source_find_image.html">SourceFindImage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classstp_1_1_source_find_image.html" title="The SourceFindImage class for source detection. ">SourceFindImage</a> class for source detection.  <a href="classstp_1_1_source_find_image.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstp_1_1_top_hat.html">TopHat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classstp_1_1_top_hat.html" title="The TopHat functor class. ">TopHat</a> functor class.  <a href="classstp_1_1_top_hat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstp_1_1_triangle.html">Triangle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classstp_1_1_triangle.html" title="The Triangle functor class. ">Triangle</a> functor class.  <a href="classstp_1_1_triangle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstp_1_1_w___projection_pars.html">W_ProjectionPars</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">W-projection settings.  <a href="structstp_1_1_w___projection_pars.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstp_1_1_wide_field_imaging.html">WideFieldImaging</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classstp_1_1_wide_field_imaging.html" title="The WideFieldImaging class. ">WideFieldImaging</a> class.  <a href="classstp_1_1_wide_field_imaging.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstp_1_1_zero_mem_alloc.html">ZeroMemAlloc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classstp_1_1_zero_mem_alloc.html" title="The ZeroMemAlloc buffer class. ">ZeroMemAlloc</a> buffer class.  <a href="classstp_1_1_zero_mem_alloc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a92421a2e1781ba7c1263b57c12082d58"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestp.html#a92421a2e1781ba7c1263b57c12082d58">KernelFunction</a> { <br />
&#160;&#160;<a class="el" href="namespacestp.html#a92421a2e1781ba7c1263b57c12082d58acd678285c2431c505ac62192462e0b04">KernelFunction::TopHat</a>, 
<a class="el" href="namespacestp.html#a92421a2e1781ba7c1263b57c12082d58a5e5500cb2b82eb72d550de644bd1b64b">KernelFunction::Triangle</a>, 
<a class="el" href="namespacestp.html#a92421a2e1781ba7c1263b57c12082d58a43e79bd61fa47e2cbc202a93f921c406">KernelFunction::Sinc</a>, 
<a class="el" href="namespacestp.html#a92421a2e1781ba7c1263b57c12082d58afedf7ba6075fb5526a7ace0b9385528d">KernelFunction::Gaussian</a>, 
<br />
&#160;&#160;<a class="el" href="namespacestp.html#a92421a2e1781ba7c1263b57c12082d58a74fa5da616c7dcd36f467abc96241471">KernelFunction::GaussianSinc</a>, 
<a class="el" href="namespacestp.html#a92421a2e1781ba7c1263b57c12082d58ac4993f430a3d651e7e600ff545e41fc1">KernelFunction::PSWF</a>
<br />
 }</td></tr>
<tr class="memdesc:a92421a2e1781ba7c1263b57c12082d58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum of available kernel functions.  <a href="namespacestp.html#a92421a2e1781ba7c1263b57c12082d58">More...</a><br /></td></tr>
<tr class="separator:a92421a2e1781ba7c1263b57c12082d58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a464d541245c3d8f9ea82f5d2d5484c98"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestp.html#a464d541245c3d8f9ea82f5d2d5484c98">FFTRoutine</a> { <br />
&#160;&#160;<a class="el" href="namespacestp.html#a464d541245c3d8f9ea82f5d2d5484c98a1551a8f00e3ff5f46b18636fb963ad8c">FFTRoutine::FFTW_ESTIMATE_FFT</a>, 
<a class="el" href="namespacestp.html#a464d541245c3d8f9ea82f5d2d5484c98a5b1699ed6ddd9a9360937797edfe3873">FFTRoutine::FFTW_MEASURE_FFT</a>, 
<a class="el" href="namespacestp.html#a464d541245c3d8f9ea82f5d2d5484c98af7b85ceb556fa3fccee760843b070ceb">FFTRoutine::FFTW_PATIENT_FFT</a>, 
<a class="el" href="namespacestp.html#a464d541245c3d8f9ea82f5d2d5484c98ab6cc625b02ae42496e8baea63abf1243">FFTRoutine::FFTW_WISDOM_FFT</a>, 
<br />
&#160;&#160;<a class="el" href="namespacestp.html#a464d541245c3d8f9ea82f5d2d5484c98ac68eed57a11ce9105b7e0355d5b2e84d">FFTRoutine::FFTW_WISDOM_INPLACE_FFT</a>
<br />
 }</td></tr>
<tr class="memdesc:a464d541245c3d8f9ea82f5d2d5484c98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum of available FFT algorithms.  <a href="namespacestp.html#a464d541245c3d8f9ea82f5d2d5484c98">More...</a><br /></td></tr>
<tr class="separator:a464d541245c3d8f9ea82f5d2d5484c98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ae9fed509d30e48b2a6b5c0bbcb99fe"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestp.html#a7ae9fed509d30e48b2a6b5c0bbcb99fe">InterpType</a> { <a class="el" href="namespacestp.html#a7ae9fed509d30e48b2a6b5c0bbcb99feaaac544aacc3615aada24897a215f5046">InterpType::LINEAR</a>, 
<a class="el" href="namespacestp.html#a7ae9fed509d30e48b2a6b5c0bbcb99feaccd681e34e5e40fbce74618c3ccffcff">InterpType::CUBIC</a>, 
<a class="el" href="namespacestp.html#a7ae9fed509d30e48b2a6b5c0bbcb99feae66ba018ef96aa5c78c8fba787f43717">InterpType::COSINE</a>
 }</td></tr>
<tr class="memdesc:a7ae9fed509d30e48b2a6b5c0bbcb99fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum interpolation algorithms.  <a href="namespacestp.html#a7ae9fed509d30e48b2a6b5c0bbcb99fe">More...</a><br /></td></tr>
<tr class="separator:a7ae9fed509d30e48b2a6b5c0bbcb99fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c175a4ce85e7fec4cfe1906e85c5e72"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestp.html#a6c175a4ce85e7fec4cfe1906e85c5e72">MedianMethod</a> { <a class="el" href="namespacestp.html#a6c175a4ce85e7fec4cfe1906e85c5e72a635eba164a6760bf0f3779cbc7cb66ad">MedianMethod::ZEROMEDIAN</a>, 
<a class="el" href="namespacestp.html#a6c175a4ce85e7fec4cfe1906e85c5e72a02d428ccb411ef698f65f8b9e822fd02">MedianMethod::BINMEDIAN</a>, 
<a class="el" href="namespacestp.html#a6c175a4ce85e7fec4cfe1906e85c5e72aeed200605be93af6f651f10fa90483b4">MedianMethod::BINAPPROX</a>, 
<a class="el" href="namespacestp.html#a6c175a4ce85e7fec4cfe1906e85c5e72a5aaa30bb35632a66d651feeaf6bd6ee8">MedianMethod::NTHELEMENT</a>
 }</td></tr>
<tr class="memdesc:a6c175a4ce85e7fec4cfe1906e85c5e72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum of available median methods.  <a href="namespacestp.html#a6c175a4ce85e7fec4cfe1906e85c5e72">More...</a><br /></td></tr>
<tr class="separator:a6c175a4ce85e7fec4cfe1906e85c5e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30ea75fc2a28e18b48e3a9939e3760a9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestp.html#a30ea75fc2a28e18b48e3a9939e3760a9">CeresDiffMethod</a> { <a class="el" href="namespacestp.html#a30ea75fc2a28e18b48e3a9939e3760a9ae8967ede587723717837909c3712390e">CeresDiffMethod::AutoDiff</a>, 
<a class="el" href="namespacestp.html#a30ea75fc2a28e18b48e3a9939e3760a9a4db6200d2a3fb2b994ff83a49c99a6d4">CeresDiffMethod::AutoDiff_SingleResBlk</a>, 
<a class="el" href="namespacestp.html#a30ea75fc2a28e18b48e3a9939e3760a9accc88f7642b52779190d6a143d1a8fe7">CeresDiffMethod::AnalyticDiff</a>, 
<a class="el" href="namespacestp.html#a30ea75fc2a28e18b48e3a9939e3760a9a22112738903c086da2e47ba0dc8f8d9e">CeresDiffMethod::AnalyticDiff_SingleResBlk</a>
 }</td></tr>
<tr class="memdesc:a30ea75fc2a28e18b48e3a9939e3760a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum of available differentiation methods used by ceres library for gaussian fitting.  <a href="namespacestp.html#a30ea75fc2a28e18b48e3a9939e3760a9">More...</a><br /></td></tr>
<tr class="separator:a30ea75fc2a28e18b48e3a9939e3760a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae604b01190a3a3414720a85c806fd7d6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestp.html#ae604b01190a3a3414720a85c806fd7d6">CeresSolverType</a> { <a class="el" href="namespacestp.html#ae604b01190a3a3414720a85c806fd7d6afd0d5b1f6ee7757ec90dce1107dcef00">CeresSolverType::LinearSearch_BFGS</a>, 
<a class="el" href="namespacestp.html#ae604b01190a3a3414720a85c806fd7d6a25f51874b6aac8fb933c164f9d42778c">CeresSolverType::LinearSearch_LBFGS</a>, 
<a class="el" href="namespacestp.html#ae604b01190a3a3414720a85c806fd7d6a4d89de3a5b02f9f6f445cbe2358a8675">CeresSolverType::TrustRegion_DenseQR</a>
 }</td></tr>
<tr class="memdesc:ae604b01190a3a3414720a85c806fd7d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum of available solver types used by ceres library for gaussian fitting.  <a href="namespacestp.html#ae604b01190a3a3414720a85c806fd7d6">More...</a><br /></td></tr>
<tr class="separator:ae604b01190a3a3414720a85c806fd7d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae8d9b51a632aa86b4dc0bd0ed818d3c7"><td class="memTemplParams" colspan="2">template&lt;bool findNegative = false&gt; </td></tr>
<tr class="memitem:ae8d9b51a632aa86b4dc0bd0ed818d3c7"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="classstp_1_1_mat_stp.html">MatStp</a>&lt; int &gt;, <a class="el" href="classstp_1_1_mat_stp.html">MatStp</a>&lt; uint &gt;, uint, uint &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestp.html#ae8d9b51a632aa86b4dc0bd0ed818d3c7">labeling_8con</a> (const arma::Mat&lt; <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> &gt; &amp;I, const <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> analysis_thresh_pos, const <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> analysis_thresh_neg)</td></tr>
<tr class="memdesc:ae8d9b51a632aa86b4dc0bd0ed818d3c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the connected components labeling (CCL) algorithm assuming 8-connectivity.  <a href="#ae8d9b51a632aa86b4dc0bd0ed818d3c7">More...</a><br /></td></tr>
<tr class="separator:ae8d9b51a632aa86b4dc0bd0ed818d3c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8fa1a958117b48b5cd405d3aa680678"><td class="memTemplParams" colspan="2">template&lt;bool findNegative&gt; </td></tr>
<tr class="memitem:ad8fa1a958117b48b5cd405d3aa680678"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="classstp_1_1_mat_stp.html">MatStp</a>&lt; int &gt;, <a class="el" href="classstp_1_1_mat_stp.html">MatStp</a>&lt; uint &gt;, uint, uint &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestp.html#ad8fa1a958117b48b5cd405d3aa680678">labeling_4con</a> (const arma::Mat&lt; <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> &gt; &amp;I, const <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> analysis_thresh_pos, const <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> analysis_thresh_neg)</td></tr>
<tr class="memdesc:ad8fa1a958117b48b5cd405d3aa680678"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the connected components labeling (CCL) algorithm assuming 4-connectivity.  <a href="#ad8fa1a958117b48b5cd405d3aa680678">More...</a><br /></td></tr>
<tr class="separator:ad8fa1a958117b48b5cd405d3aa680678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ceb4ec3c09055cb1fb2d418ab7f9a1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestp.html#a4ceb4ec3c09055cb1fb2d418ab7f9a1e">init_fftw</a> (<a class="el" href="namespacestp.html#a464d541245c3d8f9ea82f5d2d5484c98">FFTRoutine</a> r_fft, std::string fft_wisdom_filename)</td></tr>
<tr class="memdesc:a4ceb4ec3c09055cb1fb2d418ab7f9a1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Init FFTW threads and import FFTW wisdom file if required.  <a href="#a4ceb4ec3c09055cb1fb2d418ab7f9a1e">More...</a><br /></td></tr>
<tr class="separator:a4ceb4ec3c09055cb1fb2d418ab7f9a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca087153e5cd03672af82c1a31b2e2e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestp.html#aca087153e5cd03672af82c1a31b2e2e8">fft_fftw_c2r</a> (arma::Mat&lt; <a class="el" href="types_8h.html#a1d2a57e59f061705d305d324a80d4ca1">cx_real_t</a> &gt; &amp;input, arma::Mat&lt; <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> &gt; &amp;output, <a class="el" href="namespacestp.html#a464d541245c3d8f9ea82f5d2d5484c98">FFTRoutine</a> r_fft=<a class="el" href="namespacestp.html#a464d541245c3d8f9ea82f5d2d5484c98a1551a8f00e3ff5f46b18636fb963ad8c">FFTRoutine::FFTW_ESTIMATE_FFT</a>)</td></tr>
<tr class="memdesc:aca087153e5cd03672af82c1a31b2e2e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the backward fast fourier transform of a halfplane complex matrix using the FFTW library (complex to real FFT)  <a href="#aca087153e5cd03672af82c1a31b2e2e8">More...</a><br /></td></tr>
<tr class="separator:aca087153e5cd03672af82c1a31b2e2e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85f2ed4040ba683323398499f91142cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestp.html#a85f2ed4040ba683323398499f91142cf">fft_fftw_r2c</a> (arma::Mat&lt; <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> &gt; &amp;input, arma::Mat&lt; <a class="el" href="types_8h.html#a1d2a57e59f061705d305d324a80d4ca1">cx_real_t</a> &gt; &amp;output, <a class="el" href="namespacestp.html#a464d541245c3d8f9ea82f5d2d5484c98">FFTRoutine</a> r_fft=<a class="el" href="namespacestp.html#a464d541245c3d8f9ea82f5d2d5484c98a1551a8f00e3ff5f46b18636fb963ad8c">FFTRoutine::FFTW_ESTIMATE_FFT</a>)</td></tr>
<tr class="memdesc:a85f2ed4040ba683323398499f91142cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the forward fast fourier transform of a real matrix using the FFTW library (real to complex FFT)  <a href="#a85f2ed4040ba683323398499f91142cf">More...</a><br /></td></tr>
<tr class="separator:a85f2ed4040ba683323398499f91142cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad83c7146797af76e015385bbc11130d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestp.html#ad83c7146797af76e015385bbc11130d0">fft_fftw_c2c</a> (arma::Mat&lt; <a class="el" href="types_8h.html#a1d2a57e59f061705d305d324a80d4ca1">cx_real_t</a> &gt; &amp;input, arma::Mat&lt; <a class="el" href="types_8h.html#a1d2a57e59f061705d305d324a80d4ca1">cx_real_t</a> &gt; &amp;output, <a class="el" href="namespacestp.html#a464d541245c3d8f9ea82f5d2d5484c98">FFTRoutine</a> r_fft, bool forward=true)</td></tr>
<tr class="memdesc:ad83c7146797af76e015385bbc11130d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the forward fast fourier transform of a complex matrix using the FFTW library (complex to complex FFT)  <a href="#ad83c7146797af76e015385bbc11130d0">More...</a><br /></td></tr>
<tr class="separator:ad83c7146797af76e015385bbc11130d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52c5be3b41c5afffc90f9667adb9a620"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestp.html#a52c5be3b41c5afffc90f9667adb9a620">fft_fftw_dft_r2r_1d</a> (arma::Col&lt; <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> &gt; &amp;input, arma::Col&lt; <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> &gt; &amp;output, <a class="el" href="namespacestp.html#a464d541245c3d8f9ea82f5d2d5484c98">FFTRoutine</a> r_fft)</td></tr>
<tr class="memdesc:a52c5be3b41c5afffc90f9667adb9a620"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the forward fast fourier transform of a real vector (1D) using the FFTW library (real to complex FFT)  <a href="#a52c5be3b41c5afffc90f9667adb9a620">More...</a><br /></td></tr>
<tr class="separator:a52c5be3b41c5afffc90f9667adb9a620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4e9a876d5c753d6dd3bda54f6d85119"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestp.html#ac4e9a876d5c753d6dd3bda54f6d85119">generate_hermitian_matrix_from_nonredundant</a> (arma::Mat&lt; <a class="el" href="types_8h.html#a1d2a57e59f061705d305d324a80d4ca1">cx_real_t</a> &gt; &amp;matrix)</td></tr>
<tr class="memdesc:ac4e9a876d5c753d6dd3bda54f6d85119"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a hermitian matrix from the non-redundant values.  <a href="#ac4e9a876d5c753d6dd3bda54f6d85119">More...</a><br /></td></tr>
<tr class="separator:ac4e9a876d5c753d6dd3bda54f6d85119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8147549e9e6af9bc222ab8bd39c4407d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8147549e9e6af9bc222ab8bd39c4407d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestp.html#a8147549e9e6af9bc222ab8bd39c4407d">fftshift</a> (arma::Mat&lt; T &gt; &amp;m, bool is_forward=true)</td></tr>
<tr class="memdesc:a8147549e9e6af9bc222ab8bd39c4407d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs matrix circular shift as needed for iFFT.  <a href="#a8147549e9e6af9bc222ab8bd39c4407d">More...</a><br /></td></tr>
<tr class="separator:a8147549e9e6af9bc222ab8bd39c4407d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a289ceab89f470979ff8f3a16af91b382"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestp.html#a289ceab89f470979ff8f3a16af91b382">mat_median_exact</a> (const arma::Mat&lt; <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> &gt; &amp;data)</td></tr>
<tr class="memdesc:a289ceab89f470979ff8f3a16af91b382"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute exact median using the nth_element function.  <a href="#a289ceab89f470979ff8f3a16af91b382">More...</a><br /></td></tr>
<tr class="separator:a289ceab89f470979ff8f3a16af91b382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4a233c007f57992374feef8d621a50f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structstp_1_1_data_stats.html">DataStats</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestp.html#ae4a233c007f57992374feef8d621a50f">mat_binmedian</a> (const arma::Mat&lt; <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> &gt; &amp;data)</td></tr>
<tr class="memdesc:ae4a233c007f57992374feef8d621a50f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute exact median using a method that combines sucessive binning and nth_element function.  <a href="#ae4a233c007f57992374feef8d621a50f">More...</a><br /></td></tr>
<tr class="separator:ae4a233c007f57992374feef8d621a50f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a6eb0890f98de3f27e5342cd288672e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structstp_1_1_data_stats.html">DataStats</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestp.html#a8a6eb0890f98de3f27e5342cd288672e">mat_median_binapprox</a> (const arma::Mat&lt; <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> &gt; &amp;data)</td></tr>
<tr class="memdesc:a8a6eb0890f98de3f27e5342cd288672e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute approximation of the median using the binapprox method.  <a href="#a8a6eb0890f98de3f27e5342cd288672e">More...</a><br /></td></tr>
<tr class="separator:a8a6eb0890f98de3f27e5342cd288672e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaec4a7dcd30598f388f96794a9c44c68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structstp_1_1_data_stats.html">DataStats</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestp.html#aaec4a7dcd30598f388f96794a9c44c68">mat_mean_and_stddev</a> (const arma::Mat&lt; <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> &gt; &amp;data)</td></tr>
<tr class="memdesc:aaec4a7dcd30598f388f96794a9c44c68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute matrix mean and standard deviation at once.  <a href="#aaec4a7dcd30598f388f96794a9c44c68">More...</a><br /></td></tr>
<tr class="separator:aaec4a7dcd30598f388f96794a9c44c68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5186254c1cfa0304a9e924ec6cbda038"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestp.html#a5186254c1cfa0304a9e924ec6cbda038">mat_accumulate</a> (arma::Mat&lt; <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> &gt; &amp;data)</td></tr>
<tr class="memdesc:a5186254c1cfa0304a9e924ec6cbda038"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accumulate matrix elements (single thread implementation).  <a href="#a5186254c1cfa0304a9e924ec6cbda038">More...</a><br /></td></tr>
<tr class="separator:a5186254c1cfa0304a9e924ec6cbda038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04a59a5383b4ff8ffa4e7d988d3cd588"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestp.html#a04a59a5383b4ff8ffa4e7d988d3cd588">mat_accumulate_parallel</a> (arma::Mat&lt; <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> &gt; &amp;data)</td></tr>
<tr class="memdesc:a04a59a5383b4ff8ffa4e7d988d3cd588"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accumulate matrix elements (parallel implementation).  <a href="#a04a59a5383b4ff8ffa4e7d988d3cd588">More...</a><br /></td></tr>
<tr class="separator:a04a59a5383b4ff8ffa4e7d988d3cd588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f430dc49c6d6dc55c46cec479659419"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestp.html#a0f430dc49c6d6dc55c46cec479659419">mat_mean</a> (arma::Mat&lt; <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> &gt; &amp;data)</td></tr>
<tr class="memdesc:a0f430dc49c6d6dc55c46cec479659419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute matrix mean (single thread implementation).  <a href="#a0f430dc49c6d6dc55c46cec479659419">More...</a><br /></td></tr>
<tr class="separator:a0f430dc49c6d6dc55c46cec479659419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fb8607c7d28f9d5378ec98cfe8c2e85"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestp.html#a6fb8607c7d28f9d5378ec98cfe8c2e85">mat_mean_parallel</a> (arma::Mat&lt; <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> &gt; &amp;data)</td></tr>
<tr class="memdesc:a6fb8607c7d28f9d5378ec98cfe8c2e85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute matrix mean (parallel).  <a href="#a6fb8607c7d28f9d5378ec98cfe8c2e85">More...</a><br /></td></tr>
<tr class="separator:a6fb8607c7d28f9d5378ec98cfe8c2e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbf241d4fab47b856bbf90c229101ec8"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestp.html#acbf241d4fab47b856bbf90c229101ec8">mat_stddev_parallel</a> (arma::Mat&lt; <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> &gt; &amp;data, bool compute_mean=true, double mean=0.0)</td></tr>
<tr class="memdesc:acbf241d4fab47b856bbf90c229101ec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute matrix standard deviation (parallel).  <a href="#acbf241d4fab47b856bbf90c229101ec8">More...</a><br /></td></tr>
<tr class="separator:acbf241d4fab47b856bbf90c229101ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac80246a6034b9fe13f3decfcae23393b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestp.html#ac80246a6034b9fe13f3decfcae23393b">bilinear_interpolation</a> (int top, int bottom, int left, int right, double horizontal_position, double vertical_position, const arma::mat &amp;in_m)</td></tr>
<tr class="separator:ac80246a6034b9fe13f3decfcae23393b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd1a18f626d11eebaae47da542f454d1"><td class="memItemLeft" align="right" valign="top">arma::Mat&lt; <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestp.html#acd1a18f626d11eebaae47da542f454d1">rotate_matrix</a> (const arma::mat &amp;in_m, double angle, double cval, int out_size)</td></tr>
<tr class="separator:acd1a18f626d11eebaae47da542f454d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad37648a3b9f67014a4e20050b9d7b478"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad37648a3b9f67014a4e20050b9d7b478"><td class="memTemplItemLeft" align="right" valign="top">arma::Mat&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestp.html#ad37648a3b9f67014a4e20050b9d7b478">matrix_shift</a> (const arma::Mat&lt; T &gt; &amp;in, const int length, const int dim=0)</td></tr>
<tr class="memdesc:ad37648a3b9f67014a4e20050b9d7b478"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift elements of the input matrix in a circular manner.  <a href="#ad37648a3b9f67014a4e20050b9d7b478">More...</a><br /></td></tr>
<tr class="separator:ad37648a3b9f67014a4e20050b9d7b478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51644a197b25da95ca4b6f5b9ee4ba7a"><td class="memItemLeft" align="right" valign="top">arma::vec&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestp.html#a51644a197b25da95ca4b6f5b9ee4ba7a">__grdsf</a> (arma::vec nu)</td></tr>
<tr class="separator:a51644a197b25da95ca4b6f5b9ee4ba7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dec62be138cc7a88f2fb0eebae6c63e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1dec62be138cc7a88f2fb0eebae6c63e"><td class="memTemplItemLeft" align="right" valign="top">arma::mat&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestp.html#a1dec62be138cc7a88f2fb0eebae6c63e">make_kernel_array</a> (const T &amp;kernel_creator, int support, const arma::mat &amp;offset, int oversampling=1, bool pad=false, bool normalize=true)</td></tr>
<tr class="memdesc:a1dec62be138cc7a88f2fb0eebae6c63e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make 2D Kernel Array.  <a href="#a1dec62be138cc7a88f2fb0eebae6c63e">More...</a><br /></td></tr>
<tr class="separator:a1dec62be138cc7a88f2fb0eebae6c63e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae328999b307d32ea32e65caa64eac0b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aae328999b307d32ea32e65caa64eac0b"><td class="memTemplItemLeft" align="right" valign="top">arma::vec&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestp.html#aae328999b307d32ea32e65caa64eac0b">make_1D_kernel</a> (const T &amp;kernel_creator, int support, const double offset, int oversampling=1, bool pad=false, bool normalize=true)</td></tr>
<tr class="memdesc:aae328999b307d32ea32e65caa64eac0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make 1D Kernel Array.  <a href="#aae328999b307d32ea32e65caa64eac0b">More...</a><br /></td></tr>
<tr class="separator:aae328999b307d32ea32e65caa64eac0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a404fa9ce3a8e0427915ba3ac3aea9a16"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a404fa9ce3a8e0427915ba3ac3aea9a16"><td class="memTemplItemLeft" align="right" valign="top">arma::Col&lt; <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestp.html#a404fa9ce3a8e0427915ba3ac3aea9a16">ImgDomKernel</a> (const T &amp;kernel_creator, size_t kernel_size, bool normalize=false, bool analytic_gcf=false, <a class="el" href="namespacestp.html#a464d541245c3d8f9ea82f5d2d5484c98">FFTRoutine</a> r_fft=<a class="el" href="namespacestp.html#a464d541245c3d8f9ea82f5d2d5484c98a1551a8f00e3ff5f46b18636fb963ad8c">FFTRoutine::FFTW_ESTIMATE_FFT</a>)</td></tr>
<tr class="memdesc:a404fa9ce3a8e0427915ba3ac3aea9a16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the image-domain 1D kernel using the forward fast fourier transform or the analytic definition.  <a href="#a404fa9ce3a8e0427915ba3ac3aea9a16">More...</a><br /></td></tr>
<tr class="separator:a404fa9ce3a8e0427915ba3ac3aea9a16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7384480437bf68b0f41f58f4744be7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestp.html#aa7384480437bf68b0f41f58f4744be7c">besselj1</a> (<a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> x)</td></tr>
<tr class="separator:aa7384480437bf68b0f41f58f4744be7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a723e08fc37f8606211f7abbda740d4e1"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestp.html#a723e08fc37f8606211f7abbda740d4e1">parangle</a> (double ha, double dec_d, double lat_d)</td></tr>
<tr class="memdesc:a723e08fc37f8606211f7abbda740d4e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute parallatic angle for beam rotation.  <a href="#a723e08fc37f8606211f7abbda740d4e1">More...</a><br /></td></tr>
<tr class="separator:a723e08fc37f8606211f7abbda740d4e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad75e5145b07b51b813ec9eaa95e5ac93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestp.html#ad75e5145b07b51b813ec9eaa95e5ac93">convert_to_halfplane_visibilities</a> (arma::mat &amp;uv_lambda, arma::cx_mat &amp;vis, int kernel_support, arma::uvec &amp;good_vis)</td></tr>
<tr class="memdesc:ad75e5145b07b51b813ec9eaa95e5ac93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert visibilities for half-plane gridding and mark the ones that need to be duplicated.  <a href="#ad75e5145b07b51b813ec9eaa95e5ac93">More...</a><br /></td></tr>
<tr class="separator:ad75e5145b07b51b813ec9eaa95e5ac93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56aca5a8c2d0cff6cae946edbf7659d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestp.html#a56aca5a8c2d0cff6cae946edbf7659d2">convert_to_halfplane_visibilities</a> (arma::mat &amp;uv_lambda, arma::vec &amp;w_lambda, arma::cx_mat &amp;vis, int kernel_support, arma::uvec &amp;good_vis)</td></tr>
<tr class="memdesc:a56aca5a8c2d0cff6cae946edbf7659d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert visibilities for half-plane gridding and mark the ones that need to be duplicated (includes W-lambda array).  <a href="#a56aca5a8c2d0cff6cae946edbf7659d2">More...</a><br /></td></tr>
<tr class="separator:a56aca5a8c2d0cff6cae946edbf7659d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac088200d449ac7f780530a45d80f9775"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestp.html#ac088200d449ac7f780530a45d80f9775">average_w_planes</a> (arma::mat w_lambda, const arma::uvec &amp;good_vis, int num_wplanes, arma::vec &amp;w_avg_values, arma::ivec &amp;w_planes_idx, bool median=false)</td></tr>
<tr class="memdesc:ac088200d449ac7f780530a45d80f9775"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides the w plane into sections, averaging each section.  <a href="#ac088200d449ac7f780530a45d80f9775">More...</a><br /></td></tr>
<tr class="separator:ac088200d449ac7f780530a45d80f9775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39093b21b3a22c0e0afcef9127a185f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestp.html#a39093b21b3a22c0e0afcef9127a185f6">bounds_check_kernel_centre_locations</a> (arma::uvec &amp;good_vis, const arma::imat &amp;kernel_centre_on_grid, int image_size, int support)</td></tr>
<tr class="memdesc:a39093b21b3a22c0e0afcef9127a185f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">bounds_check_kernel_centre_locations function  <a href="#a39093b21b3a22c0e0afcef9127a185f6">More...</a><br /></td></tr>
<tr class="separator:a39093b21b3a22c0e0afcef9127a185f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2191add2b4abbc6ff7cb8c4102097ca"><td class="memItemLeft" align="right" valign="top">arma::imat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestp.html#ad2191add2b4abbc6ff7cb8c4102097ca">calculate_oversampled_kernel_indices</a> (arma::mat &amp;subpixel_coord, int oversampling)</td></tr>
<tr class="memdesc:ad2191add2b4abbc6ff7cb8c4102097ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate_oversampled_kernel_indices function  <a href="#ad2191add2b4abbc6ff7cb8c4102097ca">More...</a><br /></td></tr>
<tr class="separator:ad2191add2b4abbc6ff7cb8c4102097ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19e8b064e439617289907aeed2c00c76"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a19e8b064e439617289907aeed2c00c76"><td class="memTemplItemLeft" align="right" valign="top">arma::field&lt; arma::Mat&lt; <a class="el" href="types_8h.html#a1d2a57e59f061705d305d324a80d4ca1">cx_real_t</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestp.html#a19e8b064e439617289907aeed2c00c76">populate_kernel_cache</a> (const T &amp;kernel_creator, const int support, const int oversampling, const bool pad=false, const bool normalize=true)</td></tr>
<tr class="memdesc:a19e8b064e439617289907aeed2c00c76"><td class="mdescLeft">&#160;</td><td class="mdescRight">populate_kernel_cache function  <a href="#a19e8b064e439617289907aeed2c00c76">More...</a><br /></td></tr>
<tr class="separator:a19e8b064e439617289907aeed2c00c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8135d9e95f2df8f47c170daa507a5a7a"><td class="memTemplParams" colspan="2">template&lt;bool generateBeam = true, typename T &gt; </td></tr>
<tr class="memitem:a8135d9e95f2df8f47c170daa507a5a7a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstp_1_1_gridder_output.html">GridderOutput</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestp.html#a8135d9e95f2df8f47c170daa507a5a7a">convolve_to_grid</a> (const T &amp;kernel_creator, const int support, int image_size, arma::mat uv_lambda, arma::cx_mat vis, arma::mat vis_weights, bool kernel_exact=true, int oversampling=1, bool shift_uv=true, bool halfplane_gridding=true, const <a class="el" href="structstp_1_1_w___projection_pars.html">W_ProjectionPars</a> &amp;w_proj=<a class="el" href="structstp_1_1_w___projection_pars.html">W_ProjectionPars</a>(), arma::vec w_lambda=arma::vec(), double cell_size=0.0, bool analytic_gcf=true, <a class="el" href="namespacestp.html#a464d541245c3d8f9ea82f5d2d5484c98">FFTRoutine</a> r_fft=<a class="el" href="namespacestp.html#a464d541245c3d8f9ea82f5d2d5484c98a1551a8f00e3ff5f46b18636fb963ad8c">FFTRoutine::FFTW_ESTIMATE_FFT</a>, const <a class="el" href="structstp_1_1_a___projection_pars.html">A_ProjectionPars</a> &amp;a_proj=<a class="el" href="structstp_1_1_a___projection_pars.html">A_ProjectionPars</a>())</td></tr>
<tr class="memdesc:a8135d9e95f2df8f47c170daa507a5a7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Grid visibilities using convolutional gridding.  <a href="#a8135d9e95f2df8f47c170daa507a5a7a">More...</a><br /></td></tr>
<tr class="separator:a8135d9e95f2df8f47c170daa507a5a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a674d910ef471f5f234894a92057a0a47"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a674d910ef471f5f234894a92057a0a47"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestp.html#a674d910ef471f5f234894a92057a0a47">normalise_image_beam_result_1D</a> (arma::Mat&lt; <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> &gt; &amp;image_mat, arma::Mat&lt; <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> &gt; &amp;beam_mat, const T &amp;kernel_creator, const size_t image_size, const <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> normalization_factor, const bool analytic_gcf=true, const bool generate_beam=false, <a class="el" href="namespacestp.html#a464d541245c3d8f9ea82f5d2d5484c98">FFTRoutine</a> r_fft=<a class="el" href="namespacestp.html#a464d541245c3d8f9ea82f5d2d5484c98a1551a8f00e3ff5f46b18636fb963ad8c">FFTRoutine::FFTW_ESTIMATE_FFT</a>)</td></tr>
<tr class="memdesc:a674d910ef471f5f234894a92057a0a47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalizes the result image and beam.  <a href="#a674d910ef471f5f234894a92057a0a47">More...</a><br /></td></tr>
<tr class="separator:a674d910ef471f5f234894a92057a0a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f3931422fe088eed5e60da339a8ddab"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3f3931422fe088eed5e60da339a8ddab"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; arma::Mat&lt; <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> &gt;, arma::Mat&lt; <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestp.html#a3f3931422fe088eed5e60da339a8ddab">image_visibilities</a> (const T kernel_creator, const arma::cx_mat &amp;vis, const arma::mat &amp;vis_weights, const arma::mat &amp;uvw_lambda, const <a class="el" href="structstp_1_1_imager_pars.html">ImagerPars</a> &amp;img_pars=<a class="el" href="structstp_1_1_imager_pars.html">ImagerPars</a>(), const <a class="el" href="structstp_1_1_w___projection_pars.html">W_ProjectionPars</a> &amp;w_proj=<a class="el" href="structstp_1_1_w___projection_pars.html">W_ProjectionPars</a>(), const <a class="el" href="structstp_1_1_a___projection_pars.html">A_ProjectionPars</a> &amp;a_proj=<a class="el" href="structstp_1_1_a___projection_pars.html">A_ProjectionPars</a>())</td></tr>
<tr class="memdesc:a3f3931422fe088eed5e60da339a8ddab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates image and beam data from input visibilities.  <a href="#a3f3931422fe088eed5e60da339a8ddab">More...</a><br /></td></tr>
<tr class="separator:a3f3931422fe088eed5e60da339a8ddab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a8c4842ab9c1c71a7eb2226602296c7"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestp.html#a7a8c4842ab9c1c71a7eb2226602296c7">estimate_rms</a> (const arma::Mat&lt; <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> &gt; &amp;data, double num_sigma=3, uint iters=5, <a class="el" href="structstp_1_1_data_stats.html">DataStats</a> stats=<a class="el" href="structstp_1_1_data_stats.html">DataStats</a>())</td></tr>
<tr class="memdesc:a7a8c4842ab9c1c71a7eb2226602296c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform sigma-clip and estimate RMS of input matrix.  <a href="#a7a8c4842ab9c1c71a7eb2226602296c7">More...</a><br /></td></tr>
<tr class="separator:a7a8c4842ab9c1c71a7eb2226602296c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4376d9dfa3b7a21f1ca69629c347d99"><td class="memItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestp.html#ab4376d9dfa3b7a21f1ca69629c347d99">degree_to_rad</a> (double value)</td></tr>
<tr class="memdesc:ab4376d9dfa3b7a21f1ca69629c347d99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert value in degrees to radians.  <a href="#ab4376d9dfa3b7a21f1ca69629c347d99">More...</a><br /></td></tr>
<tr class="separator:ab4376d9dfa3b7a21f1ca69629c347d99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ff833f501186b663177e7761a61405e"><td class="memItemLeft" align="right" valign="top">arma::cx_mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestp.html#a4ff833f501186b663177e7761a61405e">visibilities_for_point_source</a> (arma::mat &amp;dist_uvw, double l, double m, double flux)</td></tr>
<tr class="memdesc:a4ff833f501186b663177e7761a61405e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simulate visibilities for point source.  <a href="#a4ff833f501186b663177e7761a61405e">More...</a><br /></td></tr>
<tr class="separator:a4ff833f501186b663177e7761a61405e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbc82270e03dee57c2a67c3a81f0369c"><td class="memItemLeft" align="right" valign="top">arma::cx_mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestp.html#afbc82270e03dee57c2a67c3a81f0369c">generate_visibilities_from_local_skymodel</a> (arma::mat &amp;skymodel, arma::mat &amp;uvw_baselines)</td></tr>
<tr class="memdesc:afbc82270e03dee57c2a67c3a81f0369c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a set of model visibilities given a skymodel and UVW-baselines.  <a href="#afbc82270e03dee57c2a67c3a81f0369c">More...</a><br /></td></tr>
<tr class="separator:afbc82270e03dee57c2a67c3a81f0369c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:af0459870232dd56e330689c1c965fde1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::chrono::high_resolution_clock::time_point &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestp.html#af0459870232dd56e330689c1c965fde1">times_iv</a></td></tr>
<tr class="separator:af0459870232dd56e330689c1c965fde1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d1222ebc087e846f7373341c1a78c8d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::chrono::high_resolution_clock::time_point &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestp.html#a0d1222ebc087e846f7373341c1a78c8d">times_sf</a></td></tr>
<tr class="separator:a0d1222ebc087e846f7373341c1a78c8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58ba99386f0132f0554a749dedc6c07a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::chrono::high_resolution_clock::time_point &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestp.html#a58ba99386f0132f0554a749dedc6c07a">times_ccl</a></td></tr>
<tr class="separator:a58ba99386f0132f0554a749dedc6c07a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a640f9d473d4790d262ed74f21ecc3335"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestp.html#a640f9d473d4790d262ed74f21ecc3335">fptolerance</a> = 1.0e-10</td></tr>
<tr class="separator:a640f9d473d4790d262ed74f21ecc3335"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a30ea75fc2a28e18b48e3a9939e3760a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30ea75fc2a28e18b48e3a9939e3760a9">&#9670;&nbsp;</a></span>CeresDiffMethod</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacestp.html#a30ea75fc2a28e18b48e3a9939e3760a9">stp::CeresDiffMethod</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enum of available differentiation methods used by ceres library for gaussian fitting. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a30ea75fc2a28e18b48e3a9939e3760a9ae8967ede587723717837909c3712390e"></a>AutoDiff&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a30ea75fc2a28e18b48e3a9939e3760a9a4db6200d2a3fb2b994ff83a49c99a6d4"></a>AutoDiff_SingleResBlk&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a30ea75fc2a28e18b48e3a9939e3760a9accc88f7642b52779190d6a143d1a8fe7"></a>AnalyticDiff&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a30ea75fc2a28e18b48e3a9939e3760a9a22112738903c086da2e47ba0dc8f8d9e"></a>AnalyticDiff_SingleResBlk&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ae604b01190a3a3414720a85c806fd7d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae604b01190a3a3414720a85c806fd7d6">&#9670;&nbsp;</a></span>CeresSolverType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacestp.html#ae604b01190a3a3414720a85c806fd7d6">stp::CeresSolverType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enum of available solver types used by ceres library for gaussian fitting. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ae604b01190a3a3414720a85c806fd7d6afd0d5b1f6ee7757ec90dce1107dcef00"></a>LinearSearch_BFGS&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae604b01190a3a3414720a85c806fd7d6a25f51874b6aac8fb933c164f9d42778c"></a>LinearSearch_LBFGS&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae604b01190a3a3414720a85c806fd7d6a4d89de3a5b02f9f6f445cbe2358a8675"></a>TrustRegion_DenseQR&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a464d541245c3d8f9ea82f5d2d5484c98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a464d541245c3d8f9ea82f5d2d5484c98">&#9670;&nbsp;</a></span>FFTRoutine</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacestp.html#a464d541245c3d8f9ea82f5d2d5484c98">stp::FFTRoutine</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enum of available FFT algorithms. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a464d541245c3d8f9ea82f5d2d5484c98a1551a8f00e3ff5f46b18636fb963ad8c"></a>FFTW_ESTIMATE_FFT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a464d541245c3d8f9ea82f5d2d5484c98a5b1699ed6ddd9a9360937797edfe3873"></a>FFTW_MEASURE_FFT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a464d541245c3d8f9ea82f5d2d5484c98af7b85ceb556fa3fccee760843b070ceb"></a>FFTW_PATIENT_FFT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a464d541245c3d8f9ea82f5d2d5484c98ab6cc625b02ae42496e8baea63abf1243"></a>FFTW_WISDOM_FFT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a464d541245c3d8f9ea82f5d2d5484c98ac68eed57a11ce9105b7e0355d5b2e84d"></a>FFTW_WISDOM_INPLACE_FFT&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a7ae9fed509d30e48b2a6b5c0bbcb99fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ae9fed509d30e48b2a6b5c0bbcb99fe">&#9670;&nbsp;</a></span>InterpType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacestp.html#a7ae9fed509d30e48b2a6b5c0bbcb99fe">stp::InterpType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enum interpolation algorithms. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a7ae9fed509d30e48b2a6b5c0bbcb99feaaac544aacc3615aada24897a215f5046"></a>LINEAR&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a7ae9fed509d30e48b2a6b5c0bbcb99feaccd681e34e5e40fbce74618c3ccffcff"></a>CUBIC&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a7ae9fed509d30e48b2a6b5c0bbcb99feae66ba018ef96aa5c78c8fba787f43717"></a>COSINE&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a92421a2e1781ba7c1263b57c12082d58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92421a2e1781ba7c1263b57c12082d58">&#9670;&nbsp;</a></span>KernelFunction</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacestp.html#a92421a2e1781ba7c1263b57c12082d58">stp::KernelFunction</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enum of available kernel functions. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a92421a2e1781ba7c1263b57c12082d58acd678285c2431c505ac62192462e0b04"></a>TopHat&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a92421a2e1781ba7c1263b57c12082d58a5e5500cb2b82eb72d550de644bd1b64b"></a>Triangle&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a92421a2e1781ba7c1263b57c12082d58a43e79bd61fa47e2cbc202a93f921c406"></a>Sinc&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a92421a2e1781ba7c1263b57c12082d58afedf7ba6075fb5526a7ace0b9385528d"></a>Gaussian&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a92421a2e1781ba7c1263b57c12082d58a74fa5da616c7dcd36f467abc96241471"></a>GaussianSinc&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a92421a2e1781ba7c1263b57c12082d58ac4993f430a3d651e7e600ff545e41fc1"></a>PSWF&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a6c175a4ce85e7fec4cfe1906e85c5e72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c175a4ce85e7fec4cfe1906e85c5e72">&#9670;&nbsp;</a></span>MedianMethod</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacestp.html#a6c175a4ce85e7fec4cfe1906e85c5e72">stp::MedianMethod</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enum of available median methods. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6c175a4ce85e7fec4cfe1906e85c5e72a635eba164a6760bf0f3779cbc7cb66ad"></a>ZEROMEDIAN&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6c175a4ce85e7fec4cfe1906e85c5e72a02d428ccb411ef698f65f8b9e822fd02"></a>BINMEDIAN&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6c175a4ce85e7fec4cfe1906e85c5e72aeed200605be93af6f651f10fa90483b4"></a>BINAPPROX&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6c175a4ce85e7fec4cfe1906e85c5e72a5aaa30bb35632a66d651feeaf6bd6ee8"></a>NTHELEMENT&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a51644a197b25da95ca4b6f5b9ee4ba7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51644a197b25da95ca4b6f5b9ee4ba7a">&#9670;&nbsp;</a></span>__grdsf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arma::vec stp::__grdsf </td>
          <td>(</td>
          <td class="paramtype">arma::vec&#160;</td>
          <td class="paramname"><em>nu</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestp_a51644a197b25da95ca4b6f5b9ee4ba7a_icgraph.png" border="0" usemap="#namespacestp_a51644a197b25da95ca4b6f5b9ee4ba7a_icgraph" alt=""/></div>
<map name="namespacestp_a51644a197b25da95ca4b6f5b9ee4ba7a_icgraph" id="namespacestp_a51644a197b25da95ca4b6f5b9ee4ba7a_icgraph">
<area shape="rect" id="node2" href="classstp_1_1_p_s_w_f.html#a740a33ebb8f62bd49417f8a79bd04fa5" title="operator () " alt="" coords="144,5,295,32"/>
<area shape="rect" id="node3" href="classstp_1_1_p_s_w_f.html#a1061ca126f514cd0caa6f9775a5d7cae" title="Generates the 1D grid correction function (gcf) " alt="" coords="163,56,276,83"/>
</map>
</div>

</div>
</div>
<a id="ac088200d449ac7f780530a45d80f9775"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac088200d449ac7f780530a45d80f9775">&#9670;&nbsp;</a></span>average_w_planes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stp::average_w_planes </td>
          <td>(</td>
          <td class="paramtype">arma::mat&#160;</td>
          <td class="paramname"><em>w_lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arma::uvec &amp;&#160;</td>
          <td class="paramname"><em>good_vis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_wplanes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::vec &amp;&#160;</td>
          <td class="paramname"><em>w_avg_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::ivec &amp;&#160;</td>
          <td class="paramname"><em>w_planes_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>median</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Divides the w plane into sections, averaging each section. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">w_lambda</td><td>(arma::mat): W-lambda values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">good_vis</td><td>(arma::uvec): Indicates which visibilities are valid. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_wplanes</td><td>(int): number of planes to divide w_plane. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">w_planes_idx</td><td>(arma::vec): w_plane_array with num_planes elements. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">median</td><td>(bool): Use median (rather than mean) to compute W-planes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa7384480437bf68b0f41f58f4744be7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7384480437bf68b0f41f58f4744be7c">&#9670;&nbsp;</a></span>besselj1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> stp::besselj1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac80246a6034b9fe13f3decfcae23393b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac80246a6034b9fe13f3decfcae23393b">&#9670;&nbsp;</a></span>bilinear_interpolation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stp::bilinear_interpolation </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>horizontal_position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>vertical_position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arma::mat &amp;&#160;</td>
          <td class="paramname"><em>in_m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestp_ac80246a6034b9fe13f3decfcae23393b_icgraph.png" border="0" usemap="#namespacestp_ac80246a6034b9fe13f3decfcae23393b_icgraph" alt=""/></div>
<map name="namespacestp_ac80246a6034b9fe13f3decfcae23393b_icgraph" id="namespacestp_ac80246a6034b9fe13f3decfcae23393b_icgraph">
<area shape="rect" id="node2" href="namespacestp.html#acd1a18f626d11eebaae47da542f454d1" title="stp::rotate_matrix" alt="" coords="220,5,344,32"/>
</map>
</div>

</div>
</div>
<a id="a39093b21b3a22c0e0afcef9127a185f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39093b21b3a22c0e0afcef9127a185f6">&#9670;&nbsp;</a></span>bounds_check_kernel_centre_locations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stp::bounds_check_kernel_centre_locations </td>
          <td>(</td>
          <td class="paramtype">arma::uvec &amp;&#160;</td>
          <td class="paramname"><em>good_vis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arma::imat &amp;&#160;</td>
          <td class="paramname"><em>kernel_centre_on_grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>image_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>support</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>bounds_check_kernel_centre_locations function </p>
<p>Vectorized bounds check.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">good_vis</td><td>(arma::uvec): List of indices for 'good' (in-bounds) positions. Note this is a list of integer values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kernel_centre_on_grid</td><td>(arma::imat): Corresponding array of nearest-pixel grid-locations, which will be the centre position of a kernel placement. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">support</td><td>(int): Kernel support size in regular pixels. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">image_size</td><td>(int): Image width in pixels </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad2191add2b4abbc6ff7cb8c4102097ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2191add2b4abbc6ff7cb8c4102097ca">&#9670;&nbsp;</a></span>calculate_oversampled_kernel_indices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arma::imat stp::calculate_oversampled_kernel_indices </td>
          <td>(</td>
          <td class="paramtype">arma::mat &amp;&#160;</td>
          <td class="paramname"><em>subpixel_coord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>oversampling</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculate_oversampled_kernel_indices function </p>
<p>Find the nearest oversampled gridpoint for given sub-pixel offset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">subpixel_coord</td><td>(arma::mat): Array of 'fractional' co-ords, that is the subpixel offsets from nearest pixel on the regular grid. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">oversampling</td><td>(int). How many oversampled pixels to one regular pixel.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(arma::imat): Corresponding oversampled pixel indexes </dd></dl>

</div>
</div>
<a id="ad75e5145b07b51b813ec9eaa95e5ac93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad75e5145b07b51b813ec9eaa95e5ac93">&#9670;&nbsp;</a></span>convert_to_halfplane_visibilities() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stp::convert_to_halfplane_visibilities </td>
          <td>(</td>
          <td class="paramtype">arma::mat &amp;&#160;</td>
          <td class="paramname"><em>uv_lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::cx_mat &amp;&#160;</td>
          <td class="paramname"><em>vis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>kernel_support</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::uvec &amp;&#160;</td>
          <td class="paramname"><em>good_vis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert visibilities for half-plane gridding and mark the ones that need to be duplicated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">uv_lambda</td><td>(arma::mat): UV-coordinates of complex visibilities to be converted. 2D double array with 2 columns. Assumed ordering is u,v. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">vis</td><td>(arma::cx_mat): Complex visibilities to be converted (1D array). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kernel_support</td><td>(int): Kernel support. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">good_vis</td><td>(arma::uvec): Identifies visibilities to be duplicated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a56aca5a8c2d0cff6cae946edbf7659d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56aca5a8c2d0cff6cae946edbf7659d2">&#9670;&nbsp;</a></span>convert_to_halfplane_visibilities() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stp::convert_to_halfplane_visibilities </td>
          <td>(</td>
          <td class="paramtype">arma::mat &amp;&#160;</td>
          <td class="paramname"><em>uv_lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::vec &amp;&#160;</td>
          <td class="paramname"><em>w_lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::cx_mat &amp;&#160;</td>
          <td class="paramname"><em>vis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>kernel_support</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::uvec &amp;&#160;</td>
          <td class="paramname"><em>good_vis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert visibilities for half-plane gridding and mark the ones that need to be duplicated (includes W-lambda array). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">uv_lambda</td><td>(arma::mat): UV-coordinates of complex visibilities to be converted. 2D double array with 2 columns. Assumed ordering is u,v. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">w_lambda</td><td>(arma::vec): W-coordinate of complex visibilities to be converted (1D array). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">vis</td><td>(arma::cx_mat): Complex visibilities to be converted (1D array). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kernel_support</td><td>(int): Kernel support. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">good_vis</td><td>(arma::uvec): Array that identifies visibilities to be duplicated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8135d9e95f2df8f47c170daa507a5a7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8135d9e95f2df8f47c170daa507a5a7a">&#9670;&nbsp;</a></span>convolve_to_grid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool generateBeam = true, typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstp_1_1_gridder_output.html">GridderOutput</a> stp::convolve_to_grid </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>kernel_creator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>support</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>image_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::mat&#160;</td>
          <td class="paramname"><em>uv_lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::cx_mat&#160;</td>
          <td class="paramname"><em>vis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::mat&#160;</td>
          <td class="paramname"><em>vis_weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>kernel_exact</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>oversampling</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shift_uv</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>halfplane_gridding</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structstp_1_1_w___projection_pars.html">W_ProjectionPars</a> &amp;&#160;</td>
          <td class="paramname"><em>w_proj</em> = <code><a class="el" href="structstp_1_1_w___projection_pars.html">W_ProjectionPars</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::vec&#160;</td>
          <td class="paramname"><em>w_lambda</em> = <code>arma::vec()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cell_size</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>analytic_gcf</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacestp.html#a464d541245c3d8f9ea82f5d2d5484c98">FFTRoutine</a>&#160;</td>
          <td class="paramname"><em>r_fft</em> = <code><a class="el" href="namespacestp.html#a464d541245c3d8f9ea82f5d2d5484c98a1551a8f00e3ff5f46b18636fb963ad8c">FFTRoutine::FFTW_ESTIMATE_FFT</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structstp_1_1_a___projection_pars.html">A_ProjectionPars</a> &amp;&#160;</td>
          <td class="paramname"><em>a_proj</em> = <code><a class="el" href="structstp_1_1_a___projection_pars.html">A_ProjectionPars</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Grid visibilities using convolutional gridding. </p>
<p>Returns the <b>un-normalized</b> weighted visibilities; the weights-renormalization factor can be calculated by summing the sample grid.</p>
<p>If 'exact == True' then exact gridding is used, i.e. the kernel is recalculated for each visibility, with precise sub-pixel offset according to that visibility's UV co-ordinates. Otherwise, instead of recalculating the kernel for each sub-pixel location, we pre-generate an oversampled kernel ahead of time - so e.g. for an oversampling of 5, the kernel is pre-generated at 0.2 pixel-width offsets. We then pick the pre-generated kernel corresponding to the sub-pixel offset nearest to that of the visibility. Kernel pre-generation results in improved performance, particularly with large numbers of visibilities and complex kernel functions, at the cost of introducing minor aliasing effects due to the 'step-like' nature of the oversampled kernel. This in turn can be minimised (at the cost of longer start-up times and larger memory usage) by pre-generating kernels with a larger oversampling ratio, to give finer interpolation. This function also performs W-projection and A-projection when these parameters are provided.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">T&amp;</td><td>kernel_creator : the kernel creator functor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">support</td><td>(int) : Defines the 'radius' of the bounding box within which convolution takes place. <code>Box width in pixels = 2*support+1</code>. (The central pixel is the one nearest to the UV co-ordinates.) (This is sometimes known as the 'half-support') </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">image_size</td><td>(int) : Width of the image in pixels. NB we assume the pixel <code>[image_size//2,image_size//2]</code> corresponds to the origin in UV-space. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uv_lambda</td><td>(arma::mat) : UV-coordinates of input visibilities. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vis</td><td>(arma::cx_mat) : Complex visibilities. 1d array, shape: (n_vis). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vis_weights</td><td>(arma::mat) : Visibility weights. 1d array, shape: (n_vis). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kernel_exact</td><td>(bool) : Calculate exact kernel-values for every UV-sample. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">oversampling</td><td>(int) : Controls kernel-generation if <code>exact==False</code>. Larger values give a finer-sampled set of pre-cached kernels. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">shift_uv</td><td>(bool) : Shift uv-coordinates before gridding (required when fftshift function is skipped before fft). Default is true. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">halfplane_gridding</td><td>(bool) : Grid only halfplane matrix. Used when halfplane c2r fft will be applied. Default is true. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">w_proj</td><td>(<a class="el" href="structstp_1_1_w___projection_pars.html" title="W-projection settings. ">W_ProjectionPars</a>) : W-projection configuration parameters. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">w_lambda</td><td>(arma::vec) : W-coordinate of input visibilities. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cell_size</td><td>(double) : Angular-width of a synthesized pixel in the image to be created (arcsecond). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">analytic_gcf</td><td>(bool): Compute approximation of image-domain kernel from analytic expression. Default is true. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r_fft</td><td>(FFTRoutine): Selects FFT routine. Default is FFTW_ESTIMATE_FFT. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_proj</td><td>(<a class="el" href="structstp_1_1_a___projection_pars.html" title="A-projection settings. ">A_ProjectionPars</a>) : A-projection configuration parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(GridderRes): stores vis_grid and sampling_grid, representing the visibility grid and the sampling grid matrices. Includes also value with the total sampling grid sum. </dd></dl>

</div>
</div>
<a id="ab4376d9dfa3b7a21f1ca69629c347d99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4376d9dfa3b7a21f1ca69629c347d99">&#9670;&nbsp;</a></span>degree_to_rad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr double stp::degree_to_rad </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert value in degrees to radians. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>(double): value in degrees</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(double): value in radians </dd></dl>

</div>
</div>
<a id="a7a8c4842ab9c1c71a7eb2226602296c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a8c4842ab9c1c71a7eb2226602296c7">&#9670;&nbsp;</a></span>estimate_rms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double stp::estimate_rms </td>
          <td>(</td>
          <td class="paramtype">const arma::Mat&lt; <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>num_sigma</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>iters</em> = <code>5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstp_1_1_data_stats.html">DataStats</a>&#160;</td>
          <td class="paramname"><em>stats</em> = <code><a class="el" href="structstp_1_1_data_stats.html">DataStats</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform sigma-clip and estimate RMS of input matrix. </p>
<p>Compute Root mean square of input data after sigma-clipping (combines RMS estimation and sigma clip functions for improved computational performance). Sigma clip is based on the pyhton's sigma_clip function in astropy.stats.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>(arma::Mat): Input data matrix. Data is not changed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sigma</td><td>(double): The number of standard deviations to use for both the lower and upper clipping limit. Defaults to 3. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iters</td><td>(uint): The number of iterations for sigma clipping. Defaults to 5. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stats</td><td>(<a class="el" href="structstp_1_1_data_stats.html" title="Struct that stores computed statistics: mean, sigma, median. ">DataStats</a>): The mean, sigma and median values to be used. If data stats are not passed (non-valid), they are computed internally.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(double): Computed Root Mean Square value. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestp_a7a8c4842ab9c1c71a7eb2226602296c7_cgraph.png" border="0" usemap="#namespacestp_a7a8c4842ab9c1c71a7eb2226602296c7_cgraph" alt=""/></div>
<map name="namespacestp_a7a8c4842ab9c1c71a7eb2226602296c7_cgraph" id="namespacestp_a7a8c4842ab9c1c71a7eb2226602296c7_cgraph">
<area shape="rect" id="node2" href="namespacestp.html#ae4a233c007f57992374feef8d621a50f" title="Compute exact median using a method that combines sucessive binning and nth_element function..." alt="" coords="180,56,316,83"/>
<area shape="rect" id="node3" href="namespacestp.html#aaec4a7dcd30598f388f96794a9c44c68" title="Compute matrix mean and standard deviation at once. " alt="" coords="364,5,547,32"/>
<area shape="rect" id="node4" href="namespacestp.html#a289ceab89f470979ff8f3a16af91b382" title="Compute exact median using the nth_element function. " alt="" coords="376,56,535,83"/>
</map>
</div>

</div>
</div>
<a id="ad83c7146797af76e015385bbc11130d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad83c7146797af76e015385bbc11130d0">&#9670;&nbsp;</a></span>fft_fftw_c2c()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stp::fft_fftw_c2c </td>
          <td>(</td>
          <td class="paramtype">arma::Mat&lt; <a class="el" href="types_8h.html#a1d2a57e59f061705d305d324a80d4ca1">cx_real_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::Mat&lt; <a class="el" href="types_8h.html#a1d2a57e59f061705d305d324a80d4ca1">cx_real_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacestp.html#a464d541245c3d8f9ea82f5d2d5484c98">FFTRoutine</a>&#160;</td>
          <td class="paramname"><em>r_fft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>forward</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the forward fast fourier transform of a complex matrix using the FFTW library (complex to complex FFT) </p>
<p>Receives the complex matrix (n_rows = n_cols) and performs the forward fast fourier transform returning a complex output matrix. Find more details about c2c (complex to complex) FFT in the FFTW manual.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>(arma::Mat) : Complex input matrix to be transformed using fft </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">output</td><td>(arma::Mat) : Complex halfplane output matrix with the fft result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r_fft</td><td>(FFTRoutine enum) : FFT routine to be used: defines the FFTW planner flag </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestp_ad83c7146797af76e015385bbc11130d0_icgraph.png" border="0" usemap="#namespacestp_ad83c7146797af76e015385bbc11130d0_icgraph" alt=""/></div>
<map name="namespacestp_ad83c7146797af76e015385bbc11130d0_icgraph" id="namespacestp_ad83c7146797af76e015385bbc11130d0_icgraph">
<area shape="rect" id="node2" href="classstp_1_1_wide_field_imaging.html#a99e16ca0726a77ff2a43692b79372ab0" title="Generate convolution kernel at oversampled&#45;pixel offsets for A&#45;Projection. " alt="" coords="171,5,324,61"/>
<area shape="rect" id="node3" href="classstp_1_1_wide_field_imaging.html#a9a8453c69c2a794052f6cb991d959e66" title="Generate convolution kernel at oversampled&#45;pixel offsets for W&#45;Projection. " alt="" coords="171,85,324,141"/>
</map>
</div>

</div>
</div>
<a id="aca087153e5cd03672af82c1a31b2e2e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca087153e5cd03672af82c1a31b2e2e8">&#9670;&nbsp;</a></span>fft_fftw_c2r()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stp::fft_fftw_c2r </td>
          <td>(</td>
          <td class="paramtype">arma::Mat&lt; <a class="el" href="types_8h.html#a1d2a57e59f061705d305d324a80d4ca1">cx_real_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::Mat&lt; <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacestp.html#a464d541245c3d8f9ea82f5d2d5484c98">FFTRoutine</a>&#160;</td>
          <td class="paramname"><em>r_fft</em> = <code><a class="el" href="namespacestp.html#a464d541245c3d8f9ea82f5d2d5484c98a1551a8f00e3ff5f46b18636fb963ad8c">FFTRoutine::FFTW_ESTIMATE_FFT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the backward fast fourier transform of a halfplane complex matrix using the FFTW library (complex to real FFT) </p>
<p>Receives the halfplane complex matrix (n_rows = n_cols/2 +1) and performs the backward fast fourier transform returning a real output matrix. Find more details about c2r (complex to real) FFT in the FFTW manual.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>(arma::Mat) : Complex input matrix to be transformed using fft </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">output</td><td>(arma::Mat) : Real output matrix with the fft result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r_fft</td><td>(FFTRoutine enum) : FFT routine to be used: defines the FFTW planner flag </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestp_aca087153e5cd03672af82c1a31b2e2e8_icgraph.png" border="0" usemap="#namespacestp_aca087153e5cd03672af82c1a31b2e2e8_icgraph" alt=""/></div>
<map name="namespacestp_aca087153e5cd03672af82c1a31b2e2e8_icgraph" id="namespacestp_aca087153e5cd03672af82c1a31b2e2e8_icgraph">
<area shape="rect" id="node2" href="namespacestp.html#a3f3931422fe088eed5e60da339a8ddab" title="Generates image and beam data from input visibilities. " alt="" coords="168,13,315,39"/>
<area shape="rect" id="node3" href="classstp_1_1_image_visibilities.html#aa1e9b6dff9caa156aff9293d9e92d3b6" title="ImageVisibilities constructor. " alt="" coords="363,5,505,47"/>
</map>
</div>

</div>
</div>
<a id="a52c5be3b41c5afffc90f9667adb9a620"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52c5be3b41c5afffc90f9667adb9a620">&#9670;&nbsp;</a></span>fft_fftw_dft_r2r_1d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stp::fft_fftw_dft_r2r_1d </td>
          <td>(</td>
          <td class="paramtype">arma::Col&lt; <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::Col&lt; <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacestp.html#a464d541245c3d8f9ea82f5d2d5484c98">FFTRoutine</a>&#160;</td>
          <td class="paramname"><em>r_fft</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the forward fast fourier transform of a real vector (1D) using the FFTW library (real to complex FFT) </p>
<p>Receives the real vector and performs the forward fast fourier transform returning a complex output vector in halfcomplex format as specified by FFTW_R2HC transform kind (first all real values and then all imaginary values). This allows the output and input arrays having the same size. Find more details about r2r (real to real) FFT in the FFTW manual.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>(arma::Mat) : Real input vector to be transformed using fft </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">output</td><td>(arma::Mat) : Real halfplane output vector with the fft result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r_fft</td><td>(FFTRoutine enum) : FFT routine to be used: defines the FFTW planner flag </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestp_a52c5be3b41c5afffc90f9667adb9a620_icgraph.png" border="0" usemap="#namespacestp_a52c5be3b41c5afffc90f9667adb9a620_icgraph" alt=""/></div>
<map name="namespacestp_a52c5be3b41c5afffc90f9667adb9a620_icgraph" id="namespacestp_a52c5be3b41c5afffc90f9667adb9a620_icgraph">
<area shape="rect" id="node2" href="namespacestp.html#a404fa9ce3a8e0427915ba3ac3aea9a16" title="Computes the image&#45;domain 1D kernel using the forward fast fourier transform or the analytic definiti..." alt="" coords="208,13,343,39"/>
<area shape="rect" id="node3" href="namespacestp.html#a674d910ef471f5f234894a92057a0a47" title="Normalizes the result image and beam. " alt="" coords="391,5,537,47"/>
<area shape="rect" id="node4" href="namespacestp.html#a3f3931422fe088eed5e60da339a8ddab" title="Generates image and beam data from input visibilities. " alt="" coords="585,13,732,39"/>
<area shape="rect" id="node5" href="classstp_1_1_image_visibilities.html#aa1e9b6dff9caa156aff9293d9e92d3b6" title="ImageVisibilities constructor. " alt="" coords="780,5,923,47"/>
</map>
</div>

</div>
</div>
<a id="a85f2ed4040ba683323398499f91142cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85f2ed4040ba683323398499f91142cf">&#9670;&nbsp;</a></span>fft_fftw_r2c()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stp::fft_fftw_r2c </td>
          <td>(</td>
          <td class="paramtype">arma::Mat&lt; <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::Mat&lt; <a class="el" href="types_8h.html#a1d2a57e59f061705d305d324a80d4ca1">cx_real_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacestp.html#a464d541245c3d8f9ea82f5d2d5484c98">FFTRoutine</a>&#160;</td>
          <td class="paramname"><em>r_fft</em> = <code><a class="el" href="namespacestp.html#a464d541245c3d8f9ea82f5d2d5484c98a1551a8f00e3ff5f46b18636fb963ad8c">FFTRoutine::FFTW_ESTIMATE_FFT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the forward fast fourier transform of a real matrix using the FFTW library (real to complex FFT) </p>
<p>Receives the real matrix (n_rows = n_cols) and performs the forward fast fourier transform returning a complex output matrix. Find more details about r2c (real to complex) FFT in the FFTW manual.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>(arma::Mat) : Real input matrix to be transformed using fft </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">output</td><td>(arma::Mat) : Complex halfplane output matrix with the fft result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r_fft</td><td>(FFTRoutine enum) : FFT routine to be used: defines the FFTW planner flag </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8147549e9e6af9bc222ab8bd39c4407d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8147549e9e6af9bc222ab8bd39c4407d">&#9670;&nbsp;</a></span>fftshift()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stp::fftshift </td>
          <td>(</td>
          <td class="paramtype">arma::Mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_forward</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs matrix circular shift as needed for iFFT. </p>
<p>Shift the zero-frequency component to the centre of the spectrum.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>(arma::Mat&lt;T&gt;) : The matrix to be shifted (shifted matrix is also stored here) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_forward</td><td>(bool) Shifts forward if true (default), backward otherwise </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestp_a8147549e9e6af9bc222ab8bd39c4407d_cgraph.png" border="0" usemap="#namespacestp_a8147549e9e6af9bc222ab8bd39c4407d_cgraph" alt=""/></div>
<map name="namespacestp_a8147549e9e6af9bc222ab8bd39c4407d_cgraph" id="namespacestp_a8147549e9e6af9bc222ab8bd39c4407d_cgraph">
<area shape="rect" id="node2" href="namespacestp.html#ad37648a3b9f67014a4e20050b9d7b478" title="Shift elements of the input matrix in a circular manner. " alt="" coords="139,5,255,32"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestp_a8147549e9e6af9bc222ab8bd39c4407d_icgraph.png" border="0" usemap="#namespacestp_a8147549e9e6af9bc222ab8bd39c4407d_icgraph" alt=""/></div>
<map name="namespacestp_a8147549e9e6af9bc222ab8bd39c4407d_icgraph" id="namespacestp_a8147549e9e6af9bc222ab8bd39c4407d_icgraph">
<area shape="rect" id="node2" href="namespacestp.html#a3f3931422fe088eed5e60da339a8ddab" title="Generates image and beam data from input visibilities. " alt="" coords="139,13,285,39"/>
<area shape="rect" id="node3" href="classstp_1_1_image_visibilities.html#aa1e9b6dff9caa156aff9293d9e92d3b6" title="ImageVisibilities constructor. " alt="" coords="333,5,476,47"/>
</map>
</div>

</div>
</div>
<a id="ac4e9a876d5c753d6dd3bda54f6d85119"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4e9a876d5c753d6dd3bda54f6d85119">&#9670;&nbsp;</a></span>generate_hermitian_matrix_from_nonredundant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stp::generate_hermitian_matrix_from_nonredundant </td>
          <td>(</td>
          <td class="paramtype">arma::Mat&lt; <a class="el" href="types_8h.html#a1d2a57e59f061705d305d324a80d4ca1">cx_real_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a hermitian matrix from the non-redundant values. </p>
<p>Receives a complex matrix with the non-redundant values (as returned by the fft_r2c FFTW function) which is used to generate the full hermitian matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>(arma::Mat) : Complex matrix with the non-redundant values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afbc82270e03dee57c2a67c3a81f0369c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbc82270e03dee57c2a67c3a81f0369c">&#9670;&nbsp;</a></span>generate_visibilities_from_local_skymodel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arma::cx_mat stp::generate_visibilities_from_local_skymodel </td>
          <td>(</td>
          <td class="paramtype">arma::mat &amp;&#160;</td>
          <td class="paramname"><em>skymodel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::mat &amp;&#160;</td>
          <td class="paramname"><em>uvw_baselines</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a set of model visibilities given a skymodel and UVW-baselines. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">skymodel</td><td>(arma::mat): The local skymodel. Array of triples [l,m,flux_jy], where 'l,m' are the directional cosines for this source, and 'flux_jy' is flux in Janskys. Shape: (n_baselines, 3) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uvw_baselines</td><td>(arma::mat): UVW baselines (units of lambda). Shape: (n_baselines, 3)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>arma::cx_mat: Complex visibilities sum for each baseline. Length: n_baselines. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestp_afbc82270e03dee57c2a67c3a81f0369c_cgraph.png" border="0" usemap="#namespacestp_afbc82270e03dee57c2a67c3a81f0369c_cgraph" alt=""/></div>
<map name="namespacestp_afbc82270e03dee57c2a67c3a81f0369c_cgraph" id="namespacestp_afbc82270e03dee57c2a67c3a81f0369c_cgraph">
<area shape="rect" id="node2" href="namespacestp.html#a4ff833f501186b663177e7761a61405e" title="Simulate visibilities for point source. " alt="" coords="216,5,343,47"/>
</map>
</div>

</div>
</div>
<a id="a3f3931422fe088eed5e60da339a8ddab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f3931422fe088eed5e60da339a8ddab">&#9670;&nbsp;</a></span>image_visibilities()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;arma::Mat&lt;<a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a>&gt;, arma::Mat&lt;<a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a>&gt; &gt; stp::image_visibilities </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>kernel_creator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arma::cx_mat &amp;&#160;</td>
          <td class="paramname"><em>vis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arma::mat &amp;&#160;</td>
          <td class="paramname"><em>vis_weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arma::mat &amp;&#160;</td>
          <td class="paramname"><em>uvw_lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structstp_1_1_imager_pars.html">ImagerPars</a> &amp;&#160;</td>
          <td class="paramname"><em>img_pars</em> = <code><a class="el" href="structstp_1_1_imager_pars.html">ImagerPars</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structstp_1_1_w___projection_pars.html">W_ProjectionPars</a> &amp;&#160;</td>
          <td class="paramname"><em>w_proj</em> = <code><a class="el" href="structstp_1_1_w___projection_pars.html">W_ProjectionPars</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structstp_1_1_a___projection_pars.html">A_ProjectionPars</a> &amp;&#160;</td>
          <td class="paramname"><em>a_proj</em> = <code><a class="el" href="structstp_1_1_a___projection_pars.html">A_ProjectionPars</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates image and beam data from input visibilities. </p>
<p>Performs convolutional gridding of input visibilities and applies ifft. Returns two arrays representing the image map and beam model.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">kernel_creator</td><td>(typename T): Callable object that returns a convolution kernel. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vis</td><td>(arma::cx_mat): Complex visibilities (1D array). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vis_weights</td><td>(arma::mat): Visibility weights (1D array). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uvw_lambda</td><td>(arma::mat): UVW-coordinates of complex visibilities. Units are multiples of wavelength. 2D double array with 3 columns. Assumed ordering is u,v,w. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">img_pars</td><td>(<a class="el" href="structstp_1_1_imager_pars.html" title="Imager settings. ">ImagerPars</a>): Imager parameters (see <a class="el" href="structstp_1_1_imager_pars.html" title="Imager settings. ">ImagerPars</a> struct). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">w_proj</td><td>(<a class="el" href="structstp_1_1_w___projection_pars.html" title="W-projection settings. ">W_ProjectionPars</a>): W-projection parameters (see <a class="el" href="structstp_1_1_w___projection_pars.html" title="W-projection settings. ">W_ProjectionPars</a> struct). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_proj</td><td>(<a class="el" href="structstp_1_1_a___projection_pars.html" title="A-projection settings. ">A_ProjectionPars</a>): A-projection parameters (see <a class="el" href="structstp_1_1_a___projection_pars.html" title="A-projection settings. ">A_ProjectionPars</a> struct).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(std::pair&lt;arma::mat, arma::mat&gt;): Two matrices representing the generated image map and beam model (image, beam). </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestp_a3f3931422fe088eed5e60da339a8ddab_cgraph.png" border="0" usemap="#namespacestp_a3f3931422fe088eed5e60da339a8ddab_cgraph" alt=""/></div>
<map name="namespacestp_a3f3931422fe088eed5e60da339a8ddab_cgraph" id="namespacestp_a3f3931422fe088eed5e60da339a8ddab_cgraph">
<area shape="rect" id="node2" href="namespacestp.html#a4ceb4ec3c09055cb1fb2d418ab7f9a1e" title="Init FFTW threads and import FFTW wisdom file if required. " alt="" coords="226,5,321,32"/>
<area shape="rect" id="node3" href="namespacestp.html#aca087153e5cd03672af82c1a31b2e2e8" title="Performs the backward fast fourier transform of a halfplane complex matrix using the FFTW library (co..." alt="" coords="216,56,331,83"/>
<area shape="rect" id="node4" href="classstp_1_1_mat_stp.html#abae20e2ed72546a78609ae8b0295359c" title="Delete matrix buffer. " alt="" coords="210,107,337,133"/>
<area shape="rect" id="node5" href="namespacestp.html#a8147549e9e6af9bc222ab8bd39c4407d" title="Performs matrix circular shift as needed for iFFT. " alt="" coords="231,157,316,184"/>
<area shape="rect" id="node7" href="namespacestp.html#a674d910ef471f5f234894a92057a0a47" title="Normalizes the result image and beam. " alt="" coords="200,209,347,250"/>
<area shape="rect" id="node6" href="namespacestp.html#ad37648a3b9f67014a4e20050b9d7b478" title="Shift elements of the input matrix in a circular manner. " alt="" coords="404,157,520,184"/>
<area shape="rect" id="node8" href="namespacestp.html#a404fa9ce3a8e0427915ba3ac3aea9a16" title="Computes the image&#45;domain 1D kernel using the forward fast fourier transform or the analytic definiti..." alt="" coords="395,216,529,243"/>
<area shape="rect" id="node9" href="namespacestp.html#a52c5be3b41c5afffc90f9667adb9a620" title="Performs the forward fast fourier transform of a real vector (1D) using the FFTW library (real to com..." alt="" coords="577,216,732,243"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestp_a3f3931422fe088eed5e60da339a8ddab_icgraph.png" border="0" usemap="#namespacestp_a3f3931422fe088eed5e60da339a8ddab_icgraph" alt=""/></div>
<map name="namespacestp_a3f3931422fe088eed5e60da339a8ddab_icgraph" id="namespacestp_a3f3931422fe088eed5e60da339a8ddab_icgraph">
<area shape="rect" id="node2" href="classstp_1_1_image_visibilities.html#aa1e9b6dff9caa156aff9293d9e92d3b6" title="ImageVisibilities constructor. " alt="" coords="200,5,343,47"/>
</map>
</div>

</div>
</div>
<a id="a404fa9ce3a8e0427915ba3ac3aea9a16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a404fa9ce3a8e0427915ba3ac3aea9a16">&#9670;&nbsp;</a></span>ImgDomKernel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma::Col&lt;<a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a>&gt; stp::ImgDomKernel </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>kernel_creator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>kernel_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>normalize</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>analytic_gcf</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacestp.html#a464d541245c3d8f9ea82f5d2d5484c98">FFTRoutine</a>&#160;</td>
          <td class="paramname"><em>r_fft</em> = <code><a class="el" href="namespacestp.html#a464d541245c3d8f9ea82f5d2d5484c98a1551a8f00e3ff5f46b18636fb963ad8c">FFTRoutine::FFTW_ESTIMATE_FFT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the image-domain 1D kernel using the forward fast fourier transform or the analytic definition. </p>
<p>Function (template + functor) to create 1D Kernel array with some specs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">kernel_creator</td><td>functor used for kernel generation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kernel_size</td><td>(size_t): Defines the array size. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">normalize</td><td>(bool): Whether to normalize output or not. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">analytic_gfc</td><td>(bool): Use analytic definition if true. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r_fft</td><td>(FFTRoutine): Selects FFT routine to be used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(arma::Col&lt;real_t&gt;): 1D array of the image domain kernel </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestp_a404fa9ce3a8e0427915ba3ac3aea9a16_cgraph.png" border="0" usemap="#namespacestp_a404fa9ce3a8e0427915ba3ac3aea9a16_cgraph" alt=""/></div>
<map name="namespacestp_a404fa9ce3a8e0427915ba3ac3aea9a16_cgraph" id="namespacestp_a404fa9ce3a8e0427915ba3ac3aea9a16_cgraph">
<area shape="rect" id="node2" href="namespacestp.html#a52c5be3b41c5afffc90f9667adb9a620" title="Performs the forward fast fourier transform of a real vector (1D) using the FFTW library (real to com..." alt="" coords="188,5,343,32"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestp_a404fa9ce3a8e0427915ba3ac3aea9a16_icgraph.png" border="0" usemap="#namespacestp_a404fa9ce3a8e0427915ba3ac3aea9a16_icgraph" alt=""/></div>
<map name="namespacestp_a404fa9ce3a8e0427915ba3ac3aea9a16_icgraph" id="namespacestp_a404fa9ce3a8e0427915ba3ac3aea9a16_icgraph">
<area shape="rect" id="node2" href="namespacestp.html#a674d910ef471f5f234894a92057a0a47" title="Normalizes the result image and beam. " alt="" coords="188,5,335,47"/>
<area shape="rect" id="node3" href="namespacestp.html#a3f3931422fe088eed5e60da339a8ddab" title="Generates image and beam data from input visibilities. " alt="" coords="383,13,529,39"/>
<area shape="rect" id="node4" href="classstp_1_1_image_visibilities.html#aa1e9b6dff9caa156aff9293d9e92d3b6" title="ImageVisibilities constructor. " alt="" coords="577,5,720,47"/>
</map>
</div>

</div>
</div>
<a id="a4ceb4ec3c09055cb1fb2d418ab7f9a1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ceb4ec3c09055cb1fb2d418ab7f9a1e">&#9670;&nbsp;</a></span>init_fftw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stp::init_fftw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacestp.html#a464d541245c3d8f9ea82f5d2d5484c98">FFTRoutine</a>&#160;</td>
          <td class="paramname"><em>r_fft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>fft_wisdom_filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Init FFTW threads and import FFTW wisdom file if required. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">r_fft</td><td>(FFTRoutine enum) : FFT routine to be used: defines the FFTW planner flag </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fft_wisdom_filename</td><td>(string): FFTW wisdom filename for FFT execution. </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestp_a4ceb4ec3c09055cb1fb2d418ab7f9a1e_icgraph.png" border="0" usemap="#namespacestp_a4ceb4ec3c09055cb1fb2d418ab7f9a1e_icgraph" alt=""/></div>
<map name="namespacestp_a4ceb4ec3c09055cb1fb2d418ab7f9a1e_icgraph" id="namespacestp_a4ceb4ec3c09055cb1fb2d418ab7f9a1e_icgraph">
<area shape="rect" id="node2" href="namespacestp.html#a3f3931422fe088eed5e60da339a8ddab" title="Generates image and beam data from input visibilities. " alt="" coords="148,13,295,39"/>
<area shape="rect" id="node3" href="classstp_1_1_image_visibilities.html#aa1e9b6dff9caa156aff9293d9e92d3b6" title="ImageVisibilities constructor. " alt="" coords="343,5,485,47"/>
</map>
</div>

</div>
</div>
<a id="ad8fa1a958117b48b5cd405d3aa680678"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8fa1a958117b48b5cd405d3aa680678">&#9670;&nbsp;</a></span>labeling_4con()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool findNegative&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;<a class="el" href="classstp_1_1_mat_stp.html">MatStp</a>&lt;int&gt;, <a class="el" href="classstp_1_1_mat_stp.html">MatStp</a>&lt;uint&gt;, uint, uint&gt; stp::labeling_4con </td>
          <td>(</td>
          <td class="paramtype">const arma::Mat&lt; <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a>&#160;</td>
          <td class="paramname"><em>analysis_thresh_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a>&#160;</td>
          <td class="paramname"><em>analysis_thresh_neg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the connected components labeling (CCL) algorithm assuming 4-connectivity. </p>
<p>Algorithm is based on "Two Strategies to Speed up Connected Components Algorithms", the SAUF (Scan array union find) variant using decision trees. Kesheng Wu, et al Note: rows are encoded as position in the "rows" array to save lookup times</p>
<p>Uses a parallel implementation which divides the input image in horizontal slices (power of 2 size). This function does not perform the final labeling stage. The label map is thus returned using temporary labels. This design decision allows to merge the final labeling stage with the search of max/min sources, performed after this step. For this reason, the array of decision tree is returned by this function to be used in the final labeling stage.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">I</td><td>(arma::Mat) : Input data matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">analysis_thresh_pos</td><td>(real_t) : Analysis threshold for detection of positive sources </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">analysis_thresh_neg</td><td>(real_t) : Analysis threshold for detection of negative sources</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(std::tuple) Tuple object containing the label map matrix (arma::Mat), the array of decision tree (arma::Mat), the mumber of positive labels (uint) and the number of negative labels (uint) </dd></dl>

</div>
</div>
<a id="ae8d9b51a632aa86b4dc0bd0ed818d3c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8d9b51a632aa86b4dc0bd0ed818d3c7">&#9670;&nbsp;</a></span>labeling_8con()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool findNegative = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;<a class="el" href="classstp_1_1_mat_stp.html">MatStp</a>&lt;int&gt;, <a class="el" href="classstp_1_1_mat_stp.html">MatStp</a>&lt;uint&gt;, uint, uint&gt; stp::labeling_8con </td>
          <td>(</td>
          <td class="paramtype">const arma::Mat&lt; <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a>&#160;</td>
          <td class="paramname"><em>analysis_thresh_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a>&#160;</td>
          <td class="paramname"><em>analysis_thresh_neg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the connected components labeling (CCL) algorithm assuming 8-connectivity. </p>
<p>Algorithm is based on "Two Strategies to Speed up Connected Components Algorithms", the SAUF (Scan array union find) variant using decision trees. Kesheng Wu, et al Note: rows are encoded as position in the "rows" array to save lookup times</p>
<p>Uses a parallel implementation which divides the input image in horizontal slices (power of 2 size). This function does not perform the final labeling stage. The label map is thus returned using temporary labels. This design decision allows to merge the final labeling stage with the search of max/min sources, performed after this step. For this reason, the array of decision tree is returned by this function to be used in the final labeling stage.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">I</td><td>(arma::Mat) : Input data matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">analysis_thresh_pos</td><td>(real_t) : Analysis threshold for detection of positive sources </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">analysis_thresh_neg</td><td>(real_t) : Analysis threshold for detection of negative sources</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(std::tuple) Tuple object containing the label map matrix (arma::Mat), the array of decision tree (arma::Mat), the mumber of positive labels (uint) and the number of negative labels (uint) </dd></dl>

</div>
</div>
<a id="aae328999b307d32ea32e65caa64eac0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae328999b307d32ea32e65caa64eac0b">&#9670;&nbsp;</a></span>make_1D_kernel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma::vec stp::make_1D_kernel </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>kernel_creator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>support</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>oversampling</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pad</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>normalize</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make 1D Kernel Array. </p>
<p>Function (template + functor) to create 1D Kernel array with some specs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">kernel_creator</td><td>functor used for kernel generation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">support</td><td>(int): Defines the 'radius' of the bounding box within which convolution takes place. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>(double): subpixel offset from the sampling position of the central pixel to the origin of the kernel function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">oversampling</td><td>(int): Controls kernel-generation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pad</td><td>(bool): Whether to pad the array by an extra pixel-width. This is used when generating an oversampled kernel that will be used for interpolation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">normalize</td><td>(bool): Whether or not the returned image should be normalized</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(arma::vec) Result 1D kernel </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestp_aae328999b307d32ea32e65caa64eac0b_icgraph.png" border="0" usemap="#namespacestp_aae328999b307d32ea32e65caa64eac0b_icgraph" alt=""/></div>
<map name="namespacestp_aae328999b307d32ea32e65caa64eac0b_icgraph" id="namespacestp_aae328999b307d32ea32e65caa64eac0b_icgraph">
<area shape="rect" id="node2" href="namespacestp.html#a19e8b064e439617289907aeed2c00c76" title="populate_kernel_cache function " alt="" coords="200,5,339,47"/>
</map>
</div>

</div>
</div>
<a id="a1dec62be138cc7a88f2fb0eebae6c63e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dec62be138cc7a88f2fb0eebae6c63e">&#9670;&nbsp;</a></span>make_kernel_array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma::mat stp::make_kernel_array </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>kernel_creator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>support</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arma::mat &amp;&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>oversampling</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pad</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>normalize</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make 2D Kernel Array. </p>
<p>Function (template + functor) to create a Kernel array with some specs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">kernel_creator</td><td>functor used for kernel generation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">support</td><td>(int): Defines the 'radius' of the bounding box within which convolution takes place. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>(arma::vec): 2-vector subpixel offset from the sampling position of the central pixel to the origin of the kernel function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">oversampling</td><td>(int): Controls kernel-generation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pad</td><td>(bool): Whether to pad the array by an extra pixel-width. This is used when generating an oversampled kernel that will be used for interpolation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">normalize</td><td>(bool): Whether or not the returned image should be normalized</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result kernel </dd></dl>

</div>
</div>
<a id="a5186254c1cfa0304a9e924ec6cbda038"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5186254c1cfa0304a9e924ec6cbda038">&#9670;&nbsp;</a></span>mat_accumulate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double stp::mat_accumulate </td>
          <td>(</td>
          <td class="paramtype">arma::Mat&lt; <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accumulate matrix elements (single thread implementation). </p>
<p>Provides single threaded implementation of matrix elements' accumulation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>(arma::Mat): Input matrix with elements to be accumulated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(double): Accumulation value. </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestp_a5186254c1cfa0304a9e924ec6cbda038_icgraph.png" border="0" usemap="#namespacestp_a5186254c1cfa0304a9e924ec6cbda038_icgraph" alt=""/></div>
<map name="namespacestp_a5186254c1cfa0304a9e924ec6cbda038_icgraph" id="namespacestp_a5186254c1cfa0304a9e924ec6cbda038_icgraph">
<area shape="rect" id="node2" href="namespacestp.html#a0f430dc49c6d6dc55c46cec479659419" title="Compute matrix mean (single thread implementation). " alt="" coords="197,5,307,32"/>
</map>
</div>

</div>
</div>
<a id="a04a59a5383b4ff8ffa4e7d988d3cd588"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04a59a5383b4ff8ffa4e7d988d3cd588">&#9670;&nbsp;</a></span>mat_accumulate_parallel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double stp::mat_accumulate_parallel </td>
          <td>(</td>
          <td class="paramtype">arma::Mat&lt; <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accumulate matrix elements (parallel implementation). </p>
<p>Provides parallel implementation of matrix elements' accumulation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>(arma::Mat): Input matrix with elements to be accumulated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(double): Accumulation value. </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestp_a04a59a5383b4ff8ffa4e7d988d3cd588_icgraph.png" border="0" usemap="#namespacestp_a04a59a5383b4ff8ffa4e7d988d3cd588_icgraph" alt=""/></div>
<map name="namespacestp_a04a59a5383b4ff8ffa4e7d988d3cd588_icgraph" id="namespacestp_a04a59a5383b4ff8ffa4e7d988d3cd588_icgraph">
<area shape="rect" id="node2" href="namespacestp.html#a6fb8607c7d28f9d5378ec98cfe8c2e85" title="Compute matrix mean (parallel). " alt="" coords="197,13,355,39"/>
<area shape="rect" id="node3" href="namespacestp.html#acbf241d4fab47b856bbf90c229101ec8" title="Compute matrix standard deviation (parallel). " alt="" coords="403,13,567,39"/>
</map>
</div>

</div>
</div>
<a id="ae4a233c007f57992374feef8d621a50f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4a233c007f57992374feef8d621a50f">&#9670;&nbsp;</a></span>mat_binmedian()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstp_1_1_data_stats.html">DataStats</a> stp::mat_binmedian </td>
          <td>(</td>
          <td class="paramtype">const arma::Mat&lt; <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute exact median using a method that combines sucessive binning and nth_element function. </p>
<p>Provides parallel implementation of modified binmedian - a fast method to find exact median. The method is based on binmedian algorithm (by Ryan Tibshirani) available at: <a href="http://www.stat.cmu.edu/~ryantibs/median/">http://www.stat.cmu.edu/~ryantibs/median/</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>(arma::Mat): Input matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(<a class="el" href="structstp_1_1_data_stats.html" title="Struct that stores computed statistics: mean, sigma, median. ">DataStats</a>): Exact median, mean and sigma. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestp_ae4a233c007f57992374feef8d621a50f_cgraph.png" border="0" usemap="#namespacestp_ae4a233c007f57992374feef8d621a50f_cgraph" alt=""/></div>
<map name="namespacestp_ae4a233c007f57992374feef8d621a50f_cgraph" id="namespacestp_ae4a233c007f57992374feef8d621a50f_cgraph">
<area shape="rect" id="node2" href="namespacestp.html#aaec4a7dcd30598f388f96794a9c44c68" title="Compute matrix mean and standard deviation at once. " alt="" coords="189,5,372,32"/>
<area shape="rect" id="node3" href="namespacestp.html#a289ceab89f470979ff8f3a16af91b382" title="Compute exact median using the nth_element function. " alt="" coords="201,56,360,83"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestp_ae4a233c007f57992374feef8d621a50f_icgraph.png" border="0" usemap="#namespacestp_ae4a233c007f57992374feef8d621a50f_icgraph" alt=""/></div>
<map name="namespacestp_ae4a233c007f57992374feef8d621a50f_icgraph" id="namespacestp_ae4a233c007f57992374feef8d621a50f_icgraph">
<area shape="rect" id="node2" href="namespacestp.html#a7a8c4842ab9c1c71a7eb2226602296c7" title="Perform sigma&#45;clip and estimate RMS of input matrix. " alt="" coords="189,5,316,32"/>
</map>
</div>

</div>
</div>
<a id="a0f430dc49c6d6dc55c46cec479659419"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f430dc49c6d6dc55c46cec479659419">&#9670;&nbsp;</a></span>mat_mean()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double stp::mat_mean </td>
          <td>(</td>
          <td class="paramtype">arma::Mat&lt; <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute matrix mean (single thread implementation). </p>
<p>Provides single threaded implementation of matrix mean.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>(arma::Mat): Input matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(double): Mean value of input matrix. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestp_a0f430dc49c6d6dc55c46cec479659419_cgraph.png" border="0" usemap="#namespacestp_a0f430dc49c6d6dc55c46cec479659419_cgraph" alt=""/></div>
<map name="namespacestp_a0f430dc49c6d6dc55c46cec479659419_cgraph" id="namespacestp_a0f430dc49c6d6dc55c46cec479659419_cgraph">
<area shape="rect" id="node2" href="namespacestp.html#a5186254c1cfa0304a9e924ec6cbda038" title="Accumulate matrix elements (single thread implementation). " alt="" coords="163,5,307,32"/>
</map>
</div>

</div>
</div>
<a id="aaec4a7dcd30598f388f96794a9c44c68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaec4a7dcd30598f388f96794a9c44c68">&#9670;&nbsp;</a></span>mat_mean_and_stddev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstp_1_1_data_stats.html">DataStats</a> stp::mat_mean_and_stddev </td>
          <td>(</td>
          <td class="paramtype">const arma::Mat&lt; <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute matrix mean and standard deviation at once. </p>
<p>Provides parallel implementation of matrix mean and standard deviation. This function uses a single loop over data to compute both quantities at once and thus get better performance. It does not use a numerically stable implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>(arma::Mat): Input matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(<a class="el" href="structstp_1_1_data_stats.html" title="Struct that stores computed statistics: mean, sigma, median. ">DataStats</a>): Mean and standard deviation values. </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestp_aaec4a7dcd30598f388f96794a9c44c68_icgraph.png" border="0" usemap="#namespacestp_aaec4a7dcd30598f388f96794a9c44c68_icgraph" alt=""/></div>
<map name="namespacestp_aaec4a7dcd30598f388f96794a9c44c68_icgraph" id="namespacestp_aaec4a7dcd30598f388f96794a9c44c68_icgraph">
<area shape="rect" id="node2" href="namespacestp.html#ae4a233c007f57992374feef8d621a50f" title="Compute exact median using a method that combines sucessive binning and nth_element function..." alt="" coords="259,5,395,32"/>
<area shape="rect" id="node3" href="namespacestp.html#a7a8c4842ab9c1c71a7eb2226602296c7" title="Perform sigma&#45;clip and estimate RMS of input matrix. " alt="" coords="467,31,593,57"/>
<area shape="rect" id="node4" href="namespacestp.html#a8a6eb0890f98de3f27e5342cd288672e" title="Compute approximation of the median using the binapprox method. " alt="" coords="236,107,419,133"/>
</map>
</div>

</div>
</div>
<a id="a6fb8607c7d28f9d5378ec98cfe8c2e85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fb8607c7d28f9d5378ec98cfe8c2e85">&#9670;&nbsp;</a></span>mat_mean_parallel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double stp::mat_mean_parallel </td>
          <td>(</td>
          <td class="paramtype">arma::Mat&lt; <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute matrix mean (parallel). </p>
<p>Provides parallel implementation of matrix mean.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>(arma::Mat): Input matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(double): Mean value of input matrix. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestp_a6fb8607c7d28f9d5378ec98cfe8c2e85_cgraph.png" border="0" usemap="#namespacestp_a6fb8607c7d28f9d5378ec98cfe8c2e85_cgraph" alt=""/></div>
<map name="namespacestp_a6fb8607c7d28f9d5378ec98cfe8c2e85_cgraph" id="namespacestp_a6fb8607c7d28f9d5378ec98cfe8c2e85_cgraph">
<area shape="rect" id="node2" href="namespacestp.html#a04a59a5383b4ff8ffa4e7d988d3cd588" title="Accumulate matrix elements (parallel implementation). " alt="" coords="211,5,355,47"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestp_a6fb8607c7d28f9d5378ec98cfe8c2e85_icgraph.png" border="0" usemap="#namespacestp_a6fb8607c7d28f9d5378ec98cfe8c2e85_icgraph" alt=""/></div>
<map name="namespacestp_a6fb8607c7d28f9d5378ec98cfe8c2e85_icgraph" id="namespacestp_a6fb8607c7d28f9d5378ec98cfe8c2e85_icgraph">
<area shape="rect" id="node2" href="namespacestp.html#acbf241d4fab47b856bbf90c229101ec8" title="Compute matrix standard deviation (parallel). " alt="" coords="211,5,375,32"/>
</map>
</div>

</div>
</div>
<a id="a8a6eb0890f98de3f27e5342cd288672e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a6eb0890f98de3f27e5342cd288672e">&#9670;&nbsp;</a></span>mat_median_binapprox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstp_1_1_data_stats.html">DataStats</a> stp::mat_median_binapprox </td>
          <td>(</td>
          <td class="paramtype">const arma::Mat&lt; <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute approximation of the median using the binapprox method. </p>
<p>Provides parallel implementation of the binapprox method to compute an approximation of the median. The median error is guaranteed to be inferior to sigma/1000. An algorithm description and its paper (by Ryan Tibshirani) are available at: <a href="http://www.stat.cmu.edu/~ryantibs/median/">http://www.stat.cmu.edu/~ryantibs/median/</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>(arma::Mat): Input matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(<a class="el" href="structstp_1_1_data_stats.html" title="Struct that stores computed statistics: mean, sigma, median. ">DataStats</a>): Approximation of the median value. Also returns mean and sigma. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestp_a8a6eb0890f98de3f27e5342cd288672e_cgraph.png" border="0" usemap="#namespacestp_a8a6eb0890f98de3f27e5342cd288672e_cgraph" alt=""/></div>
<map name="namespacestp_a8a6eb0890f98de3f27e5342cd288672e_cgraph" id="namespacestp_a8a6eb0890f98de3f27e5342cd288672e_cgraph">
<area shape="rect" id="node2" href="namespacestp.html#aaec4a7dcd30598f388f96794a9c44c68" title="Compute matrix mean and standard deviation at once. " alt="" coords="236,5,419,32"/>
<area shape="rect" id="node3" href="namespacestp.html#a289ceab89f470979ff8f3a16af91b382" title="Compute exact median using the nth_element function. " alt="" coords="248,56,407,83"/>
</map>
</div>

</div>
</div>
<a id="a289ceab89f470979ff8f3a16af91b382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a289ceab89f470979ff8f3a16af91b382">&#9670;&nbsp;</a></span>mat_median_exact()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double stp::mat_median_exact </td>
          <td>(</td>
          <td class="paramtype">const arma::Mat&lt; <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute exact median using the nth_element function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>(arma::Mat): Input matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(double): Exact median. </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestp_a289ceab89f470979ff8f3a16af91b382_icgraph.png" border="0" usemap="#namespacestp_a289ceab89f470979ff8f3a16af91b382_icgraph" alt=""/></div>
<map name="namespacestp_a289ceab89f470979ff8f3a16af91b382_icgraph" id="namespacestp_a289ceab89f470979ff8f3a16af91b382_icgraph">
<area shape="rect" id="node2" href="namespacestp.html#ae4a233c007f57992374feef8d621a50f" title="Compute exact median using a method that combines sucessive binning and nth_element function..." alt="" coords="235,5,371,32"/>
<area shape="rect" id="node4" href="namespacestp.html#a8a6eb0890f98de3f27e5342cd288672e" title="Compute approximation of the median using the binapprox method. " alt="" coords="212,56,395,83"/>
<area shape="rect" id="node3" href="namespacestp.html#a7a8c4842ab9c1c71a7eb2226602296c7" title="Perform sigma&#45;clip and estimate RMS of input matrix. " alt="" coords="443,5,569,32"/>
</map>
</div>

</div>
</div>
<a id="acbf241d4fab47b856bbf90c229101ec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbf241d4fab47b856bbf90c229101ec8">&#9670;&nbsp;</a></span>mat_stddev_parallel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double stp::mat_stddev_parallel </td>
          <td>(</td>
          <td class="paramtype">arma::Mat&lt; <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>compute_mean</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mean</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute matrix standard deviation (parallel). </p>
<p>Provides parallel implementation of matrix standard deviation. If a pre-computed mean value is received, mean calculation is bypassed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>(arma::Mat): Input matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bool</td><td>(compute_mean): Indicate if the mean value is an input or if it must be computed (default = true). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">double</td><td>(mean): Pre-computed mean value (required only when compute_mean is false).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(double): Standard deviation of input matrix. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestp_acbf241d4fab47b856bbf90c229101ec8_cgraph.png" border="0" usemap="#namespacestp_acbf241d4fab47b856bbf90c229101ec8_cgraph" alt=""/></div>
<map name="namespacestp_acbf241d4fab47b856bbf90c229101ec8_cgraph" id="namespacestp_acbf241d4fab47b856bbf90c229101ec8_cgraph">
<area shape="rect" id="node2" href="namespacestp.html#a6fb8607c7d28f9d5378ec98cfe8c2e85" title="Compute matrix mean (parallel). " alt="" coords="217,13,375,39"/>
<area shape="rect" id="node3" href="namespacestp.html#a04a59a5383b4ff8ffa4e7d988d3cd588" title="Accumulate matrix elements (parallel implementation). " alt="" coords="423,5,567,47"/>
</map>
</div>

</div>
</div>
<a id="ad37648a3b9f67014a4e20050b9d7b478"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad37648a3b9f67014a4e20050b9d7b478">&#9670;&nbsp;</a></span>matrix_shift()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma::Mat&lt;T&gt; stp::matrix_shift </td>
          <td>(</td>
          <td class="paramtype">const arma::Mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shift elements of the input matrix in a circular manner. </p>
<p>Provides matrix shift operation based on armadillo implementation, but it uses TBB for parallel processing. Template function allows to shift diferent matrix types, e.g. arma::mat, arma::cx_mat</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>(arma::Mat&lt;T&gt;): Matrix to be shifted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lenght</td><td>(int): Number of positions to shifted (can be positive or negative). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim(int)</td><td>If dim=0, shift each column by "lenght". If dim=1, shift each row by "lenght". Default is 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(arma::Mat&lt;T&gt; ): Shifted version of input matrix. </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestp_ad37648a3b9f67014a4e20050b9d7b478_icgraph.png" border="0" usemap="#namespacestp_ad37648a3b9f67014a4e20050b9d7b478_icgraph" alt=""/></div>
<map name="namespacestp_ad37648a3b9f67014a4e20050b9d7b478_icgraph" id="namespacestp_ad37648a3b9f67014a4e20050b9d7b478_icgraph">
<area shape="rect" id="node2" href="namespacestp.html#a8147549e9e6af9bc222ab8bd39c4407d" title="Performs matrix circular shift as needed for iFFT. " alt="" coords="169,13,255,39"/>
<area shape="rect" id="node3" href="namespacestp.html#a3f3931422fe088eed5e60da339a8ddab" title="Generates image and beam data from input visibilities. " alt="" coords="303,13,449,39"/>
<area shape="rect" id="node4" href="classstp_1_1_image_visibilities.html#aa1e9b6dff9caa156aff9293d9e92d3b6" title="ImageVisibilities constructor. " alt="" coords="497,5,640,47"/>
</map>
</div>

</div>
</div>
<a id="a674d910ef471f5f234894a92057a0a47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a674d910ef471f5f234894a92057a0a47">&#9670;&nbsp;</a></span>normalise_image_beam_result_1D()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stp::normalise_image_beam_result_1D </td>
          <td>(</td>
          <td class="paramtype">arma::Mat&lt; <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>image_mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::Mat&lt; <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>beam_mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>kernel_creator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>image_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a>&#160;</td>
          <td class="paramname"><em>normalization_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>analytic_gcf</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>generate_beam</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacestp.html#a464d541245c3d8f9ea82f5d2d5484c98">FFTRoutine</a>&#160;</td>
          <td class="paramname"><em>r_fft</em> = <code><a class="el" href="namespacestp.html#a464d541245c3d8f9ea82f5d2d5484c98a1551a8f00e3ff5f46b18636fb963ad8c">FFTRoutine::FFTW_ESTIMATE_FFT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalizes the result image and beam. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">image_mat</td><td>(std::pair&lt;arma::mat): Image matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">beam_mat</td><td>(std::pair&lt;arma::mat): Beam model matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kernel_creator</td><td>(typename T): Callable object that returns a convolution kernel. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">image_size</td><td>(int): Width of the image in pixels. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">normalization_factor</td><td>(int): Normalization factor computed from sampling grid. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">analytic_gcf</td><td>(bool): Compute approximation of image-domain kernel from analytic expression or DFT. Default is true. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">generate_beam</td><td>(bool): Enables generation of gridded sampling matrix. Default is false. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r_fft</td><td>(FFTRoutine): Selects FFT routine. </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestp_a674d910ef471f5f234894a92057a0a47_cgraph.png" border="0" usemap="#namespacestp_a674d910ef471f5f234894a92057a0a47_cgraph" alt=""/></div>
<map name="namespacestp_a674d910ef471f5f234894a92057a0a47_cgraph" id="namespacestp_a674d910ef471f5f234894a92057a0a47_cgraph">
<area shape="rect" id="node2" href="namespacestp.html#a404fa9ce3a8e0427915ba3ac3aea9a16" title="Computes the image&#45;domain 1D kernel using the forward fast fourier transform or the analytic definiti..." alt="" coords="200,13,335,39"/>
<area shape="rect" id="node3" href="namespacestp.html#a52c5be3b41c5afffc90f9667adb9a620" title="Performs the forward fast fourier transform of a real vector (1D) using the FFTW library (real to com..." alt="" coords="383,13,537,39"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestp_a674d910ef471f5f234894a92057a0a47_icgraph.png" border="0" usemap="#namespacestp_a674d910ef471f5f234894a92057a0a47_icgraph" alt=""/></div>
<map name="namespacestp_a674d910ef471f5f234894a92057a0a47_icgraph" id="namespacestp_a674d910ef471f5f234894a92057a0a47_icgraph">
<area shape="rect" id="node2" href="namespacestp.html#a3f3931422fe088eed5e60da339a8ddab" title="Generates image and beam data from input visibilities. " alt="" coords="200,13,347,39"/>
<area shape="rect" id="node3" href="classstp_1_1_image_visibilities.html#aa1e9b6dff9caa156aff9293d9e92d3b6" title="ImageVisibilities constructor. " alt="" coords="395,5,537,47"/>
</map>
</div>

</div>
</div>
<a id="a723e08fc37f8606211f7abbda740d4e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a723e08fc37f8606211f7abbda740d4e1">&#9670;&nbsp;</a></span>parangle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double stp::parangle </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dec_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lat_d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute parallatic angle for beam rotation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ha</td><td>(double): Hour angle of the object, in decimal hours (0,24) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dec_d</td><td>(double): Declination of the object, in degrees </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lat_d</td><td>(double): The latitude of the observer, in degrees </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(double): Parallactic angle in radians </dd></dl>

</div>
</div>
<a id="a19e8b064e439617289907aeed2c00c76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19e8b064e439617289907aeed2c00c76">&#9670;&nbsp;</a></span>populate_kernel_cache()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma::field&lt;arma::Mat&lt;<a class="el" href="types_8h.html#a1d2a57e59f061705d305d324a80d4ca1">cx_real_t</a>&gt; &gt; stp::populate_kernel_cache </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>kernel_creator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>support</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>oversampling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>pad</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>normalize</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>populate_kernel_cache function </p>
<p>Generate a cache of normalised kernels at oversampled-pixel offsets.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">T&amp;</td><td>kernel_creator : the kernel creator functor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">support</td><td>(int): See kernel generation routine. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">oversampling</td><td>(int): Oversampling ratio value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pad</td><td>(bool) : Whether to pad the array by an extra pixel-width. This is used when generating an oversampled kernel that will be used for interpolation. Default is false. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">normalize</td><td>(bool): Whether to normalize generated kernel functions. Default is true.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(arma::field&lt;arma::mat&gt;): Mapping oversampling-pixel offsets to normalised kernels. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestp_a19e8b064e439617289907aeed2c00c76_cgraph.png" border="0" usemap="#namespacestp_a19e8b064e439617289907aeed2c00c76_cgraph" alt=""/></div>
<map name="namespacestp_a19e8b064e439617289907aeed2c00c76_cgraph" id="namespacestp_a19e8b064e439617289907aeed2c00c76_cgraph">
<area shape="rect" id="node2" href="namespacestp.html#aae328999b307d32ea32e65caa64eac0b" title="Make 1D Kernel Array. " alt="" coords="192,13,339,39"/>
</map>
</div>

</div>
</div>
<a id="acd1a18f626d11eebaae47da542f454d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd1a18f626d11eebaae47da542f454d1">&#9670;&nbsp;</a></span>rotate_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arma::Mat&lt; <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> &gt; stp::rotate_matrix </td>
          <td>(</td>
          <td class="paramtype">const arma::mat &amp;&#160;</td>
          <td class="paramname"><em>in_m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>out_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestp_acd1a18f626d11eebaae47da542f454d1_cgraph.png" border="0" usemap="#namespacestp_acd1a18f626d11eebaae47da542f454d1_cgraph" alt=""/></div>
<map name="namespacestp_acd1a18f626d11eebaae47da542f454d1_cgraph" id="namespacestp_acd1a18f626d11eebaae47da542f454d1_cgraph">
<area shape="rect" id="node2" href="namespacestp.html#ac80246a6034b9fe13f3decfcae23393b" title="stp::bilinear_interpolation" alt="" coords="177,5,344,32"/>
</map>
</div>

</div>
</div>
<a id="a4ff833f501186b663177e7761a61405e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ff833f501186b663177e7761a61405e">&#9670;&nbsp;</a></span>visibilities_for_point_source()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arma::cx_mat stp::visibilities_for_point_source </td>
          <td>(</td>
          <td class="paramtype">arma::mat &amp;&#160;</td>
          <td class="paramname"><em>dist_uvw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>flux</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simulate visibilities for point source. </p>
<p>Calculate visibilities for a source located at angular position (l,m) relative to observed phase centre as used for calculating baselines in UVW space. Note that point source is delta function, therefore FT relationship becomes an exponential, evaluated at (uvw.lmn)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dist_uvw</td><td>(arma::mat): Array of 3-vectors representing baselines in UVW space [lambda]. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">l</td><td>(double): Direction cosines in RA direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>(double): Direction cosines in Dec direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flux</td><td>(double): Flux [Jy]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>arma::cx_mat: Array of complex visibilities </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacestp_a4ff833f501186b663177e7761a61405e_icgraph.png" border="0" usemap="#namespacestp_a4ff833f501186b663177e7761a61405e_icgraph" alt=""/></div>
<map name="namespacestp_a4ff833f501186b663177e7761a61405e_icgraph" id="namespacestp_a4ff833f501186b663177e7761a61405e_icgraph">
<area shape="rect" id="node2" href="namespacestp.html#afbc82270e03dee57c2a67c3a81f0369c" title="Generate a set of model visibilities given a skymodel and UVW&#45;baselines. " alt="" coords="180,5,343,47"/>
</map>
</div>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a640f9d473d4790d262ed74f21ecc3335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a640f9d473d4790d262ed74f21ecc3335">&#9670;&nbsp;</a></span>fptolerance</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="types_8h.html#ab46614359717672dc9a4eed4669be6e6">real_t</a> stp::fptolerance = 1.0e-10</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a58ba99386f0132f0554a749dedc6c07a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58ba99386f0132f0554a749dedc6c07a">&#9670;&nbsp;</a></span>times_ccl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::chrono::high_resolution_clock::time_point&gt; stp::times_ccl</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af0459870232dd56e330689c1c965fde1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0459870232dd56e330689c1c965fde1">&#9670;&nbsp;</a></span>times_iv</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::chrono::high_resolution_clock::time_point&gt; stp::times_iv</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0d1222ebc087e846f7373341c1a78c8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d1222ebc087e846f7373341c1a78c8d">&#9670;&nbsp;</a></span>times_sf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::chrono::high_resolution_clock::time_point &gt; stp::times_sf</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
