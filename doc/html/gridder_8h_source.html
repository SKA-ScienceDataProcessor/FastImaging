<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Slow Transients Pipeline Prototype: /home/llucas/FastImaging/src/stp/gridder/gridder.h Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="science_data_processor_logo.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Slow Transients Pipeline Prototype
   </div>
   <div id="projectbrief">Component of the Science Data Processor being developed in the context of the Square Kilometre Array international project, which provides fast snapshot imaging, object detection and cataloguing for the identification of astrophysical image-plane transients.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_71906deff00c706128a95d3938125d0a.html">stp</a></li><li class="navelem"><a class="el" href="dir_84de9b9706c9fd6890d1de19f7b2d5de.html">gridder</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">gridder.h</div>  </div>
</div><!--header-->
<div class="contents">
<a href="gridder_8h.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="preprocessor">#ifndef GRIDDER_FUNC_H</span></div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="preprocessor">#define GRIDDER_FUNC_H</span></div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<span class="preprocessor">#include &lt;cassert&gt;</span></div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="preprocessor">#include &lt;cfloat&gt;</span></div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;<span class="preprocessor">#include &lt;map&gt;</span></div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;<span class="preprocessor">#include &lt;tbb/tbb.h&gt;</span></div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;<span class="preprocessor">#include &quot;../common/matstp.h&quot;</span></div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;<span class="preprocessor">#include &quot;../convolution/conv_func.h&quot;</span></div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;<span class="preprocessor">#include &quot;../types.h&quot;</span></div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;<span class="keyword">namespace </span><a class="code" href="namespacestp.html">stp</a> {</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;</div><div class="line"><a name="l00025"></a><span class="lineno"><a class="line" href="classstp_1_1_gridder_output.html">   25</a></span>&#160;<span class="keyword">class </span><a class="code" href="classstp_1_1_gridder_output.html">GridderOutput</a> {</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;<span class="keyword">public</span>:</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;    <a class="code" href="classstp_1_1_gridder_output.html#a875fc3decf005dff279ed0d43195942b">GridderOutput</a>() = <span class="keywordflow">default</span>;</div><div class="line"><a name="l00028"></a><span class="lineno"><a class="line" href="classstp_1_1_gridder_output.html#a7de6a41a043d64b12e4b583e612e868c">   28</a></span>&#160;    <a class="code" href="classstp_1_1_gridder_output.html#a7de6a41a043d64b12e4b583e612e868c">GridderOutput</a>(<a class="code" href="classstp_1_1_mat_stp.html">MatStp&lt;cx_real_t&gt;</a>&amp; in_vis_grid, <a class="code" href="classstp_1_1_mat_stp.html">MatStp&lt;cx_real_t&gt;</a>&amp; in_sampling_grid, <span class="keywordtype">double</span> in_sampling_total)</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;        : <a class="code" href="classstp_1_1_gridder_output.html#a49a6dc4b250eff5150ec560daf3c33f5">vis_grid</a>(std::move(in_vis_grid))</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;        , <a class="code" href="classstp_1_1_gridder_output.html#a02d28321016ab51f04ecb17431583d8c">sampling_grid</a>(std::move(in_sampling_grid))</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;        , <a class="code" href="classstp_1_1_gridder_output.html#a7e3e3dc1f24e7c5e3caff9611bd0e298">sample_grid_total</a>(in_sampling_total)</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;    {</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;    }</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;</div><div class="line"><a name="l00038"></a><span class="lineno"><a class="line" href="classstp_1_1_gridder_output.html#a49a6dc4b250eff5150ec560daf3c33f5">   38</a></span>&#160;    <a class="code" href="classstp_1_1_mat_stp.html">MatStp&lt;cx_real_t&gt;</a> <a class="code" href="classstp_1_1_gridder_output.html#a49a6dc4b250eff5150ec560daf3c33f5">vis_grid</a>;</div><div class="line"><a name="l00042"></a><span class="lineno"><a class="line" href="classstp_1_1_gridder_output.html#a02d28321016ab51f04ecb17431583d8c">   42</a></span>&#160;    <a class="code" href="classstp_1_1_mat_stp.html">MatStp&lt;cx_real_t&gt;</a> <a class="code" href="classstp_1_1_gridder_output.html#a02d28321016ab51f04ecb17431583d8c">sampling_grid</a>;</div><div class="line"><a name="l00046"></a><span class="lineno"><a class="line" href="classstp_1_1_gridder_output.html#a7e3e3dc1f24e7c5e3caff9611bd0e298">   46</a></span>&#160;    <span class="keywordtype">double</span> <a class="code" href="classstp_1_1_gridder_output.html#a7e3e3dc1f24e7c5e3caff9611bd0e298">sample_grid_total</a>;</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;};</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><a name="l00063"></a><span class="lineno"><a class="line" href="namespacestp.html#a9d34b3ed2504bd5c0fc106e3299a5d62">   63</a></span>&#160;arma::field&lt;arma::mat&gt; <a class="code" href="namespacestp.html#a9d34b3ed2504bd5c0fc106e3299a5d62">populate_kernel_cache</a>(<span class="keyword">const</span> T&amp; kernel_creator, <span class="keyword">const</span> <span class="keywordtype">int</span> support, <span class="keyword">const</span> <span class="keywordtype">int</span> oversampling, <span class="keyword">const</span> <span class="keywordtype">bool</span> pad = <span class="keyword">false</span>, <span class="keyword">const</span> <span class="keywordtype">bool</span> normalize = <span class="keyword">true</span>)</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;{</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;    <span class="keywordtype">int</span> oversampled_pixel = (oversampling / 2);</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;    <span class="keywordtype">int</span> cache_size = (oversampled_pixel * 2 + 1);</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;    arma::mat oversampled_pixel_offsets = (arma::linspace(0, cache_size - 1, cache_size) - oversampled_pixel) / oversampling;</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;    arma::field&lt;arma::mat&gt; cache(cache_size, cache_size); <span class="comment">// 2D kernel array cache to be returned</span></div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;    arma::field&lt;arma::mat&gt; kernel1D_cache(cache_size); <span class="comment">// Temporary cache for 1D kernel arrays</span></div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;    <span class="comment">// Fill 1D kernel array cache</span></div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; cache_size; i++) {</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;        kernel1D_cache(i) = <a class="code" href="namespacestp.html#aae328999b307d32ea32e65caa64eac0b">make_1D_kernel</a>(kernel_creator, support, oversampled_pixel_offsets[i], 1, pad, normalize);</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;    }</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;    <span class="comment">// Generate 2D kernel array cache based on 1D kernel cache for reduced running times</span></div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; cache_size; i++) {</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt;= i; j++) {</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;            arma::mat result = kernel1D_cache(j) * kernel1D_cache(i).st();</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;            cache(j, i) = result;</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;            <span class="keywordflow">if</span> (i != j)</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;                cache(i, j) = result.st();</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;        }</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;    }</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;    <span class="keywordflow">return</span> cache;</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;}</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;<span class="keywordtype">void</span> <a class="code" href="namespacestp.html#a095277dc88e800af18a5e1e9e803792e">convert_to_halfplane_visibilities</a>(arma::mat&amp; uv_in_pixels, arma::cx_mat&amp; vis, arma::mat&amp; vis_weights, <span class="keywordtype">int</span> kernel_support);</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;arma::uvec <a class="code" href="namespacestp.html#a64e9b2a4405d8f3ded5155a4c9cdf844">bounds_check_kernel_centre_locations</a>(arma::imat&amp; kernel_centre_indices, <span class="keywordtype">int</span> support, <span class="keywordtype">int</span> image_size);</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;arma::imat <a class="code" href="namespacestp.html#ad2191add2b4abbc6ff7cb8c4102097ca">calculate_oversampled_kernel_indices</a>(arma::mat&amp; subpixel_coord, <span class="keywordtype">int</span> oversampling);</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;<span class="keyword">template</span> &lt;<span class="keywordtype">bool</span> generateBeam, <span class="keyword">typename</span> T&gt;</div><div class="line"><a name="l00173"></a><span class="lineno"><a class="line" href="namespacestp.html#a52281cb4b4f86251170ed68ec09fb59e">  173</a></span>&#160;<a class="code" href="classstp_1_1_gridder_output.html">GridderOutput</a> <a class="code" href="namespacestp.html#a52281cb4b4f86251170ed68ec09fb59e">convolve_to_grid</a>(<span class="keyword">const</span> T&amp; kernel_creator, <span class="keyword">const</span> <span class="keywordtype">int</span> support, <span class="keywordtype">int</span> image_size, arma::mat uv, arma::cx_mat vis, arma::mat vis_weights,</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;    <span class="keywordtype">bool</span> kernel_exact = <span class="keyword">true</span>, <span class="keywordtype">int</span> oversampling = 1, <span class="keywordtype">bool</span> pad = <span class="keyword">false</span>, <span class="keywordtype">bool</span> normalize = <span class="keyword">true</span>, <span class="keywordtype">bool</span> shift_uv = <span class="keyword">true</span>, <span class="keywordtype">bool</span> halfplane_gridding = <span class="keyword">true</span>)</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;{</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;    assert(uv.n_cols == 2);</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;    assert(uv.n_rows == vis.n_rows);</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;    assert(kernel_exact || (oversampling &gt;= 1));</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;    assert((image_size % 2) == 0);</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;    assert(vis.n_elem == vis_weights.n_elem);</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;    <span class="keywordflow">if</span> (kernel_exact == <span class="keyword">true</span>)</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;        oversampling = 1;</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;    <span class="comment">// If a visibility point is located in the top half-plane, move it to the bottom half-plane to a symmetric position with respect to the matrix centre (0,0)</span></div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;    <span class="keywordflow">if</span> (halfplane_gridding) {</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;        <a class="code" href="namespacestp.html#a095277dc88e800af18a5e1e9e803792e">convert_to_halfplane_visibilities</a>(uv, vis, vis_weights, support);</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;    }</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;    arma::mat uv_rounded = uv;</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;    uv_rounded.for_each([](arma::mat::elem_type&amp; val) {</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;        val = rint(val);</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;    });</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;    arma::mat uv_frac = uv - uv_rounded;</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;    arma::imat kernel_centre_on_grid = arma::conv_to&lt;arma::imat&gt;::from(uv_rounded) + (image_size / 2);</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;    <span class="comment">// Check bounds</span></div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;    arma::uvec good_vis = <a class="code" href="namespacestp.html#a64e9b2a4405d8f3ded5155a4c9cdf844">bounds_check_kernel_centre_locations</a>(kernel_centre_on_grid, support, image_size);</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;    <span class="comment">// Exclude zero-weighted visibilities</span></div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; vis_weights.n_elem; ++i) {</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;        <span class="keywordflow">if</span> (!(std::abs(vis_weights[i]) &gt; 0.0)) {</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;            good_vis[i] = 0;</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;        }</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;    }</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;    <span class="comment">// Number of rows of the output images. This changes if halfplane gridding is used</span></div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;    <span class="keywordtype">int</span> image_rows = image_size;</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;    <span class="keywordflow">if</span> (halfplane_gridding) {</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;        image_rows = (image_size / 2) + 1;</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;    }</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;    <span class="comment">// Shift positions of the visibilities (to avoid call to fftshift function)</span></div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;    <span class="keywordflow">if</span> (shift_uv) {</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;        <span class="keywordtype">int</span> shift_offset = image_size / 2;</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;        kernel_centre_on_grid.each_row([&amp;](arma::imat&amp; r) {</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;            <span class="keywordflow">if</span> (r[0] &lt; shift_offset) {</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;                r[0] += shift_offset;</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;            } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;                r[0] -= shift_offset;</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;            }</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;            <span class="keywordflow">if</span> (r[1] &lt; shift_offset) {</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;                r[1] += shift_offset;</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;            } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;                r[1] -= shift_offset;</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;            }</div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;        });</div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;    }</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;</div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;    <span class="comment">// Create matrices for output gridded images</span></div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;    <span class="comment">// Use MatStp class because these images shall be efficiently initialized with zeros</span></div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;    <a class="code" href="classstp_1_1_mat_stp.html">MatStp&lt;cx_real_t&gt;</a> <a class="code" href="classstp_1_1_gridder_output.html#a49a6dc4b250eff5150ec560daf3c33f5">vis_grid</a>(image_rows, image_size);</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;    <span class="keywordtype">int</span> sampl_image_size = 0;</div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;    <span class="keywordtype">int</span> sampl_image_rows = 0;</div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;    <span class="keywordflow">if</span> (generateBeam) {</div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;        sampl_image_size = image_size;</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;        sampl_image_rows = image_rows;</div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;    }</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;    <a class="code" href="classstp_1_1_mat_stp.html">MatStp&lt;cx_real_t&gt;</a> <a class="code" href="classstp_1_1_gridder_output.html#a02d28321016ab51f04ecb17431583d8c">sampling_grid</a>(sampl_image_rows, sampl_image_size);</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;    <span class="comment">// Used to renormalize the visibilities by the sampled weights total</span></div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;    <span class="keywordtype">double</span> <a class="code" href="classstp_1_1_gridder_output.html#a7e3e3dc1f24e7c5e3caff9611bd0e298">sample_grid_total</a> = 0;</div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;</div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;    <span class="keywordtype">int</span> kernel_size = support * 2 + 1;</div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;</div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;    <span class="keywordflow">if</span> (kernel_exact == <span class="keyword">false</span>) {</div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;        <span class="comment">// Kernel oversampled gridder</span></div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;        <span class="comment">// If an integer value is supplied (oversampling), we pre-generate an oversampled kernel ahead of time.</span></div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;        <span class="keyword">const</span> arma::field&lt;arma::mat&gt; kernel_cache = <a class="code" href="namespacestp.html#a9d34b3ed2504bd5c0fc106e3299a5d62">populate_kernel_cache</a>(kernel_creator, support, oversampling, pad, normalize);</div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;        arma::imat oversampled_offset = <a class="code" href="namespacestp.html#ad2191add2b4abbc6ff7cb8c4102097ca">calculate_oversampled_kernel_indices</a>(uv_frac, oversampling) + (oversampling / 2);</div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;</div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;<span class="preprocessor">#ifdef SERIAL_GRIDDER</span></div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;        <span class="comment">// Single-threaded implementation of oversampled gridder</span></div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;        <span class="keywordflow">for</span> (arma::uword val = 0; val &lt; good_vis.n_elem; val++) {</div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;            <span class="keywordflow">if</span> (good_vis[val] == 0) {</div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;                <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;            }</div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;            <span class="keyword">const</span> <span class="keywordtype">int</span> gc_x = kernel_centre_on_grid(val, 0);</div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;            <span class="keyword">const</span> <span class="keywordtype">int</span> gc_y = kernel_centre_on_grid(val, 1);</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;            <span class="keyword">const</span> arma::uword cp_x = oversampled_offset.at(val, 0);</div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;            <span class="keyword">const</span> arma::uword cp_y = oversampled_offset.at(val, 1);</div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;</div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; kernel_size; j++) {</div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;                <span class="keywordtype">int</span> grid_col = gc_x - support + j;</div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;                <span class="keywordflow">if</span> (grid_col &lt; 0) <span class="comment">// left/right split of the kernel</span></div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;                    grid_col += image_size;</div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;                <span class="keywordflow">if</span> (grid_col &gt;= image_size) <span class="comment">// left/right split of the kernel</span></div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;                    grid_col -= image_size;</div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;</div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; kernel_size; i++) {</div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;                    <span class="keywordtype">int</span> grid_row = gc_y - support + i;</div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;                    <span class="keywordflow">if</span> (grid_row &lt; 0) <span class="comment">// top/bottom split of the kernel. Halfplane gridding: kernel points in the negative halfplane are excluded</span></div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;                        grid_row += image_size;</div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;                    <span class="keywordflow">if</span> (grid_row &gt;= image_size) <span class="comment">// top/bottom split of the kernel. Halfplane gridding: kernel points touching the positive halfplane are used</span></div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;                        grid_row -= image_size;</div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;                    <span class="comment">// The following condition is needed for the case of halfplane gridding, because only the top halfplane visibilities are convolved</span></div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;                    <span class="keywordflow">if</span> (grid_row &lt; image_rows) {</div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;                        <span class="keyword">const</span> <span class="keywordtype">double</span> kernel_val = kernel_cache(cp_y, cp_x).at(i, j) * vis_weights[val];</div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;                        vis_grid.at(grid_row, grid_col) += vis[val] * kernel_val;</div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;                        <span class="keywordflow">if</span> (generateBeam) {</div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;                            sampling_grid.at(grid_row, grid_col) += kernel_val;</div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;                        }</div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;                        sample_grid_total += kernel_val;</div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;                        <span class="keywordflow">if</span> (halfplane_gridding &amp;&amp; ((grid_row &gt; 0) &amp;&amp; (grid_row &lt; (image_rows - 1)))) {</div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;                            sample_grid_total += kernel_val;</div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;                        }</div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;                    }</div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;                }</div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;            }</div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;        }</div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;<span class="preprocessor">#else</span></div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;        tbb::combinable&lt;double&gt; sample_grid_total_tbb(0.0);</div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;</div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;        <span class="comment">// Multi-threaded implementation of oversampled gridder (20-25% faster)</span></div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;        tbb::parallel_for(tbb::blocked_range&lt;size_t&gt;(0, kernel_size, 1), [&amp;](<span class="keyword">const</span> tbb::blocked_range&lt;size_t&gt;&amp; r) {</div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;            <span class="keywordtype">double</span>&amp; l_sample_grid_total = sample_grid_total_tbb.local();</div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;</div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;            <span class="keywordflow">for</span> (arma::uword val = 0; val &lt; good_vis.n_elem; val++) {</div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;                <span class="keywordflow">if</span> (good_vis[val] == 0) {</div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;                    <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;                }</div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;                <span class="keywordtype">int</span> gc_x = kernel_centre_on_grid(val, 0);</div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;                <span class="keywordtype">int</span> gc_y = kernel_centre_on_grid(val, 1);</div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;</div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;                <span class="keyword">const</span> arma::uword cp_x = oversampled_offset.at(val, 0);</div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;                <span class="keyword">const</span> arma::uword cp_y = oversampled_offset.at(val, 1);</div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;</div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;                <span class="keywordtype">int</span> conv_col = ((gc_x - r.begin() + kernel_size) % kernel_size);</div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;                <span class="keywordflow">if</span> (conv_col &gt; support)</div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;                    conv_col -= kernel_size;</div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;                <span class="keywordtype">int</span> grid_col = (gc_x - conv_col);</div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;                <span class="keywordflow">if</span> ((grid_col &lt; image_size) &amp;&amp; (grid_col &gt;= 0)) {</div><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;</div><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;                    assert(std::abs(conv_col) &lt;= support);</div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;                    assert(arma::uword(grid_col % kernel_size) == r.begin());</div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;</div><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;                    <span class="comment">// Pick the pre-generated kernel corresponding to the sub-pixel offset nearest to that of the visibility.</span></div><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; kernel_size; ++i) {</div><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;                        <span class="keywordtype">int</span> grid_row = gc_y - support + i;</div><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;                        <span class="keywordflow">if</span> (grid_row &lt; 0)</div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;                            grid_row += image_size;</div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;                        <span class="keywordflow">if</span> (grid_row &gt;= image_size)</div><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;                            grid_row -= image_size;</div><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;                        <span class="keywordflow">if</span> (grid_row &lt; image_rows) {</div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;                            <span class="keyword">const</span> <span class="keywordtype">double</span> kernel_val = kernel_cache(cp_y, cp_x).at(i, support - conv_col) * vis_weights[val];</div><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;                            vis_grid.at(grid_row, grid_col) += vis[val] * kernel_val;</div><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;                            <span class="keywordflow">if</span> (generateBeam) {</div><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;                                sampling_grid.at(grid_row, grid_col) += kernel_val;</div><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;                            }</div><div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;                            l_sample_grid_total += kernel_val;</div><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;                            <span class="keywordflow">if</span> (halfplane_gridding &amp;&amp; ((grid_row &gt; 0) &amp;&amp; (grid_row &lt; (image_rows - 1)))) {</div><div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;                                l_sample_grid_total += kernel_val;</div><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;                            }</div><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;                        }</div><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;                    }</div><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;                }</div><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;</div><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;                assert(gc_x &lt; image_size);</div><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;</div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;                <span class="comment">// This is for the cases when the kernel is split between the left and right margins</span></div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;                <span class="keywordflow">if</span> ((gc_x &gt;= (image_size - support)) || (gc_x &lt; support)) {</div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;                    <span class="keywordflow">if</span> (gc_x &gt;= (image_size - support)) {</div><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;                        gc_x -= image_size;</div><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;                        conv_col = ((gc_x - r.begin() + kernel_size * 2) % kernel_size);</div><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;                        <span class="keywordflow">if</span> (conv_col &gt; support)</div><div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;                            conv_col -= kernel_size;</div><div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;                        grid_col = (gc_x - conv_col);</div><div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;                        assert(std::abs(conv_col) &lt;= support);</div><div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;                    } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;                        assert(gc_x &lt; support);</div><div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;                        gc_x += image_size;</div><div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;                        conv_col = ((gc_x - r.begin() + kernel_size) % kernel_size);</div><div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;                        <span class="keywordflow">if</span> (conv_col &gt; support)</div><div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;                            conv_col -= kernel_size;</div><div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;                        grid_col = (gc_x - conv_col);</div><div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;                        assert(std::abs(conv_col) &lt;= support);</div><div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;                    }</div><div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;</div><div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;                    <span class="keywordflow">if</span> ((grid_col &lt; image_size) &amp;&amp; (grid_col &gt;= 0)) {</div><div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;                        <span class="comment">// Pick the pre-generated kernel corresponding to the sub-pixel offset nearest to that of the visibility.</span></div><div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;                        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; kernel_size; i++) {</div><div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;                            <span class="keywordtype">int</span> grid_row = gc_y - support + i;</div><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;                            <span class="keywordflow">if</span> (grid_row &lt; 0)</div><div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;                                grid_row += image_size;</div><div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;                            <span class="keywordflow">if</span> (grid_row &gt;= image_size)</div><div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;                                grid_row -= image_size;</div><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;                            <span class="keywordflow">if</span> (grid_row &lt; image_rows) {</div><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;                                <span class="keyword">const</span> <span class="keywordtype">double</span> kernel_val = kernel_cache(cp_y, cp_x).at(i, support - conv_col) * vis_weights[val];</div><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;                                vis_grid.at(grid_row, grid_col) += vis[val] * kernel_val;</div><div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;                                <span class="keywordflow">if</span> (generateBeam) {</div><div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;                                    sampling_grid.at(grid_row, grid_col) += kernel_val;</div><div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;                                }</div><div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;                                l_sample_grid_total += kernel_val;</div><div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;                                <span class="keywordflow">if</span> (halfplane_gridding &amp;&amp; ((grid_row &gt; 0) &amp;&amp; (grid_row &lt; (image_rows - 1)))) {</div><div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;                                    l_sample_grid_total += kernel_val;</div><div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;                                }</div><div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;                            }</div><div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;                        }</div><div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;                    }</div><div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;                }</div><div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;            }</div><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;        });</div><div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;</div><div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;        sample_grid_total = sample_grid_total_tbb.combine([](<span class="keyword">const</span> <span class="keywordtype">double</span>&amp; x, <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; y) { <span class="keywordflow">return</span> x + y; });</div><div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;</div><div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;    } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;        <span class="comment">// Exact gridder (slower but with more accuracy)</span></div><div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;        <span class="keywordflow">for</span> (arma::uword val = 0; val &lt; good_vis.n_elem; val++) {</div><div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;            <span class="keywordflow">if</span> (good_vis[val] == 0) {</div><div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;                <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;            }</div><div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;            <span class="keyword">const</span> <span class="keywordtype">int</span> gc_x = kernel_centre_on_grid(val, 0);</div><div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;            <span class="keyword">const</span> <span class="keywordtype">int</span> gc_y = kernel_centre_on_grid(val, 1);</div><div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;</div><div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;            <span class="comment">// Exact gridding is used, i.e. the kernel is recalculated for each visibility, with</span></div><div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;            <span class="comment">// precise sub-pixel offset according to that visibility&#39;s UV co-ordinates.</span></div><div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;            arma::mat normed_kernel_array = <a class="code" href="namespacestp.html#a1dec62be138cc7a88f2fb0eebae6c63e">make_kernel_array</a>(kernel_creator, support, uv_frac.row(val));</div><div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;</div><div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; kernel_size; j++) {</div><div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;                <span class="keywordtype">int</span> grid_col = gc_x - support + j;</div><div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;                <span class="keywordflow">if</span> (grid_col &lt; 0) <span class="comment">// left/right split of the kernel</span></div><div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;                    grid_col += image_size;</div><div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;                <span class="keywordflow">if</span> (grid_col &gt;= image_size) <span class="comment">// left/right split of the kernel</span></div><div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;                    grid_col -= image_size;</div><div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;</div><div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; kernel_size; i++) {</div><div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;                    <span class="keywordtype">int</span> grid_row = gc_y - support + i;</div><div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;                    <span class="keywordflow">if</span> (grid_row &lt; 0) <span class="comment">// top/bottom split of the kernel. Halfplane gridding: kernel points in the negative halfplane are excluded</span></div><div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;                        grid_row += image_size;</div><div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;                    <span class="keywordflow">if</span> (grid_row &gt;= image_size) <span class="comment">// top/bottom split of the kernel. Halfplane gridding: kernel points touching the positive halfplane are used</span></div><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;                        grid_row -= image_size;</div><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;                    <span class="comment">// The following condition is needed for the case of halfplane gridding, because only the top halfplane visibilities are convolved</span></div><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;                    <span class="keywordflow">if</span> (grid_row &lt; image_rows) {</div><div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;                        <span class="keyword">const</span> <span class="keywordtype">double</span> kernel_val = vis_weights[val] * normed_kernel_array.at(i, j);</div><div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;                        <a class="code" href="classstp_1_1_gridder_output.html#a49a6dc4b250eff5150ec560daf3c33f5">vis_grid</a>(grid_row, grid_col) += (vis[val] * kernel_val);</div><div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;                        <span class="keywordflow">if</span> (generateBeam) {</div><div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;                            <a class="code" href="classstp_1_1_gridder_output.html#a02d28321016ab51f04ecb17431583d8c">sampling_grid</a>(grid_row, grid_col) += kernel_val;</div><div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;                        }</div><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;                        sample_grid_total += kernel_val;</div><div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;                        <span class="keywordflow">if</span> (halfplane_gridding &amp;&amp; ((grid_row &gt; 0) &amp;&amp; (grid_row &lt; (image_rows - 1)))) {</div><div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;                            sample_grid_total += kernel_val;</div><div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;                        }</div><div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;                    }</div><div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;                }</div><div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;            }</div><div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;        }</div><div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;    }</div><div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;</div><div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;    <span class="keywordflow">return</span> std::move(<a class="code" href="classstp_1_1_gridder_output.html#a875fc3decf005dff279ed0d43195942b">GridderOutput</a>(vis_grid, sampling_grid, sample_grid_total));</div><div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;}</div><div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;}</div><div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;</div><div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;<span class="preprocessor">#endif </span><span class="comment">/* GRIDDER_FUNC_H */</span><span class="preprocessor"></span></div><div class="ttc" id="namespacestp_html_a52281cb4b4f86251170ed68ec09fb59e"><div class="ttname"><a href="namespacestp.html#a52281cb4b4f86251170ed68ec09fb59e">stp::convolve_to_grid</a></div><div class="ttdeci">GridderOutput convolve_to_grid(const T &amp;kernel_creator, const int support, int image_size, arma::mat uv, arma::cx_mat vis, arma::mat vis_weights, bool kernel_exact=true, int oversampling=1, bool pad=false, bool normalize=true, bool shift_uv=true, bool halfplane_gridding=true)</div><div class="ttdoc">Grid visibilities using convolutional gridding. </div><div class="ttdef"><b>Definition:</b> gridder.h:173</div></div>
<div class="ttc" id="classstp_1_1_gridder_output_html_a7de6a41a043d64b12e4b583e612e868c"><div class="ttname"><a href="classstp_1_1_gridder_output.html#a7de6a41a043d64b12e4b583e612e868c">stp::GridderOutput::GridderOutput</a></div><div class="ttdeci">GridderOutput(MatStp&lt; cx_real_t &gt; &amp;in_vis_grid, MatStp&lt; cx_real_t &gt; &amp;in_sampling_grid, double in_sampling_total)</div><div class="ttdef"><b>Definition:</b> gridder.h:28</div></div>
<div class="ttc" id="namespacestp_html_a9d34b3ed2504bd5c0fc106e3299a5d62"><div class="ttname"><a href="namespacestp.html#a9d34b3ed2504bd5c0fc106e3299a5d62">stp::populate_kernel_cache</a></div><div class="ttdeci">arma::field&lt; arma::mat &gt; populate_kernel_cache(const T &amp;kernel_creator, const int support, const int oversampling, const bool pad=false, const bool normalize=true)</div><div class="ttdoc">populate_kernel_cache function </div><div class="ttdef"><b>Definition:</b> gridder.h:63</div></div>
<div class="ttc" id="namespacestp_html_ad2191add2b4abbc6ff7cb8c4102097ca"><div class="ttname"><a href="namespacestp.html#ad2191add2b4abbc6ff7cb8c4102097ca">stp::calculate_oversampled_kernel_indices</a></div><div class="ttdeci">arma::imat calculate_oversampled_kernel_indices(arma::mat &amp;subpixel_coord, int oversampling)</div><div class="ttdoc">calculate_oversampled_kernel_indices function </div><div class="ttdef"><b>Definition:</b> gridder.cpp:81</div></div>
<div class="ttc" id="namespacestp_html_aae328999b307d32ea32e65caa64eac0b"><div class="ttname"><a href="namespacestp.html#aae328999b307d32ea32e65caa64eac0b">stp::make_1D_kernel</a></div><div class="ttdeci">arma::vec make_1D_kernel(const T &amp;kernel_creator, int support, const double offset, int oversampling=1, bool pad=false, bool normalize=true)</div><div class="ttdoc">Make 1D Kernel Array. </div><div class="ttdef"><b>Definition:</b> conv_func.h:298</div></div>
<div class="ttc" id="classstp_1_1_gridder_output_html"><div class="ttname"><a href="classstp_1_1_gridder_output.html">stp::GridderOutput</a></div><div class="ttdoc">The gridder output class. </div><div class="ttdef"><b>Definition:</b> gridder.h:25</div></div>
<div class="ttc" id="namespacestp_html_a095277dc88e800af18a5e1e9e803792e"><div class="ttname"><a href="namespacestp.html#a095277dc88e800af18a5e1e9e803792e">stp::convert_to_halfplane_visibilities</a></div><div class="ttdeci">void convert_to_halfplane_visibilities(arma::mat &amp;uv_in_pixels, arma::cx_mat &amp;vis, arma::mat &amp;vis_weights, int kernel_support)</div><div class="ttdoc">Convert the input visibilities to an array of half-plane visibilities. </div><div class="ttdef"><b>Definition:</b> gridder.cpp:10</div></div>
<div class="ttc" id="classstp_1_1_mat_stp_html"><div class="ttname"><a href="classstp_1_1_mat_stp.html">stp::MatStp&lt; cx_real_t &gt;</a></div></div>
<div class="ttc" id="classstp_1_1_gridder_output_html_a875fc3decf005dff279ed0d43195942b"><div class="ttname"><a href="classstp_1_1_gridder_output.html#a875fc3decf005dff279ed0d43195942b">stp::GridderOutput::GridderOutput</a></div><div class="ttdeci">GridderOutput()=default</div></div>
<div class="ttc" id="namespacestp_html_a64e9b2a4405d8f3ded5155a4c9cdf844"><div class="ttname"><a href="namespacestp.html#a64e9b2a4405d8f3ded5155a4c9cdf844">stp::bounds_check_kernel_centre_locations</a></div><div class="ttdeci">arma::uvec bounds_check_kernel_centre_locations(arma::imat &amp;kernel_centre_indices, int support, int image_size)</div><div class="ttdoc">bounds_check_kernel_centre_locations function </div><div class="ttdef"><b>Definition:</b> gridder.cpp:59</div></div>
<div class="ttc" id="classstp_1_1_gridder_output_html_a02d28321016ab51f04ecb17431583d8c"><div class="ttname"><a href="classstp_1_1_gridder_output.html#a02d28321016ab51f04ecb17431583d8c">stp::GridderOutput::sampling_grid</a></div><div class="ttdeci">MatStp&lt; cx_real_t &gt; sampling_grid</div><div class="ttdef"><b>Definition:</b> gridder.h:42</div></div>
<div class="ttc" id="classstp_1_1_gridder_output_html_a49a6dc4b250eff5150ec560daf3c33f5"><div class="ttname"><a href="classstp_1_1_gridder_output.html#a49a6dc4b250eff5150ec560daf3c33f5">stp::GridderOutput::vis_grid</a></div><div class="ttdeci">MatStp&lt; cx_real_t &gt; vis_grid</div><div class="ttdef"><b>Definition:</b> gridder.h:38</div></div>
<div class="ttc" id="namespacestp_html"><div class="ttname"><a href="namespacestp.html">stp</a></div><div class="ttdef"><b>Definition:</b> ccl.cpp:17</div></div>
<div class="ttc" id="classstp_1_1_gridder_output_html_a7e3e3dc1f24e7c5e3caff9611bd0e298"><div class="ttname"><a href="classstp_1_1_gridder_output.html#a7e3e3dc1f24e7c5e3caff9611bd0e298">stp::GridderOutput::sample_grid_total</a></div><div class="ttdeci">double sample_grid_total</div><div class="ttdef"><b>Definition:</b> gridder.h:46</div></div>
<div class="ttc" id="namespacestp_html_a1dec62be138cc7a88f2fb0eebae6c63e"><div class="ttname"><a href="namespacestp.html#a1dec62be138cc7a88f2fb0eebae6c63e">stp::make_kernel_array</a></div><div class="ttdeci">arma::mat make_kernel_array(const T &amp;kernel_creator, int support, const arma::mat &amp;offset, int oversampling=1, bool pad=false, bool normalize=true)</div><div class="ttdoc">Make 2D Kernel Array. </div><div class="ttdef"><b>Definition:</b> conv_func.h:258</div></div>
</div><!-- fragment --></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
